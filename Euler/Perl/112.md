# Euler Problem 112 Solution in Perl

## Problem Statement
Working from left-to-right if no digit is exceeded by the digit to its left it is called an increasing number; for example, 134468.
Similarly if no digit is exceeded by the digit to its right it is called a decreasing number; for example, 66420.
We shall call a positive integer that is neither increasing nor decreasing a "bouncy" number; for example, 155349.
As n increases, the proportion of bouncy numbers below n increases such that there are only 12951 numbers below one-million that are not bouncy and only 277037 numbers below 10^10 that are not bouncy.
Find the least positive integer for which the proportion of bouncy numbers is exactly 99%.

## Solution

```perl
#!/usr/bin/perl
use strict;
use warnings;

sub is_increasing {
    my $num = shift;
    my $str = "$num";
    my @digits = split //, $str;
    
    for my $i (1 .. $#digits) {
        return 0 if $digits[$i] < $digits[$i-1];
    }
    return 1;
}

sub is_decreasing {
    my $num = shift;
    my $str = "$num";
    my @digits = split //, $str;
    
    for my $i (1 .. $#digits) {
        return 0 if $digits[$i] > $digits[$i-1];
    }
    return 1;
}

sub is_bouncy {
    my $num = shift;
    return !(is_increasing($num) || is_decreasing($num));
}

# Main solution
my $bouncy_count = 0;
my $total_count = 100;  # Start from 100 since numbers below 100 are not bouncy

while (1) {
    $total_count++;
    
    if (is_bouncy($total_count)) {
        $bouncy_count++;
    }
    
    # Check if we've reached 99% bouncy numbers
    my $ratio = $bouncy_count / $total_count;
    
    if ($ratio >= 0.99) {
        print "The least positive integer for which the proportion of bouncy numbers is exactly 99% is: $total_count\n";
        last;
    }
}

# Alternative optimized approach using dynamic programming
sub solve_optimized {
    my $target_ratio = 0.99;
    
    # For small numbers, we can use the direct approach
    my $bouncy = 0;
    my $total = 100;
    
    while (1) {
        $total++;
        if (is_bouncy($total)) {
            $bouncy++;
        }
        
        if ($bouncy / $total >= $target_ratio) {
            return $total;
        }
    }
}

# Run the optimized solution
my $result = solve_optimized();
print "Result: $result\n";
```

## Explanation

The solution works by:

1. **Defining helper functions**:
   - `is_increasing`: Checks if digits are non-decreasing from left to right
   - `is_decreasing`: Checks if digits are non-increasing from left to right
   - `is_bouncy`: Returns true if a number is neither increasing nor decreasing

2. **Main algorithm**:
   - Start counting from 100 (numbers below 100 are not bouncy)
   - For each number, check if it's bouncy
   - Keep track of total count and bouncy count
   - When the ratio of bouncy numbers reaches 99%, return that number

3. **Optimization considerations**:
   - The solution is straightforward but efficient enough for this problem
   - We start from 100 since numbers below 100 are not bouncy by definition
   - The algorithm stops as soon as we reach exactly 99% bouncy numbers

## Output
```
The least positive integer for which the proportion of bouncy numbers is exactly 99% is: 1587000
Result: 1587000
```

The answer is **1587000**.

