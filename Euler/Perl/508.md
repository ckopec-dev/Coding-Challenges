# Euler Problem 508 Solution in Perl

- Find the number of ways to tile a 3×n rectangle with 2×1 dominoes
- The answer should be given modulo 10^9 + 7

Let's define states:
- f(n) = number of ways to tile a 3×n rectangle
- We can use dynamic programming with different states based on the configuration of the last column


```perl
#!/usr/bin/perl
use strict;
use warnings;

# Euler Problem 508 - Tiling a 3×n rectangle with 2×1 dominoes
# Solution using dynamic programming

my $MOD = 1000000007;

sub solve_508 {
    my $n = 10^9;  # We need to find the result for very large n
    
    # For large n, we need matrix exponentiation
    # The recurrence relation is: f(n) = 4*f(n-1) - f(n-2)
    # with initial conditions f(0) = 1, f(1) = 3
    
    # But let me double-check this with small cases:
    # n=0: 1 way (empty)
    # n=1: 3 ways (all vertical dominoes)
    # n=2: 11 ways
    
    # Actually, let's be more careful with the recurrence relation
    # Let's use the correct approach for 3×n tiling with 2×1 dominoes
    
    # For 3×n rectangle, we can derive:
    # f(n) = 4*f(n-1) - f(n-2) for n >= 2
    # f(0) = 1, f(1) = 3
    
    return matrix_power_fibonacci($n);
}

# Matrix exponentiation approach for large n
sub matrix_power_fibonacci {
    my $n = shift;
    
    # For the recurrence f(n) = 4*f(n-1) - f(n-2)
    # We can represent this as matrix multiplication:
    # [f(n)]   [4 -1] [f(n-1)]
    # [f(n-1)] = [1  0] [f(n-2)]
    
    if ($n == 0) { return 1; }
    if ($n == 1) { return 3; }
    
    my @base_matrix = (
        [4, -1],
        [1,  0]
    );
    
    my @result_matrix = matrix_power(\@base_matrix, $n - 1);
    
    # f(n) = result_matrix[0][0] * f(1) + result_matrix[0][1] * f(0)
    return ($result_matrix[0][0] * 3 + $result_matrix[0][1] * 1) % $MOD;
}

# Matrix exponentiation function
sub matrix_power {
    my ($matrix, $power) = @_;
    
    # Identity matrix
    my @result = (
        [1, 0],
        [0, 1]
    );
    
    my @base = @$matrix;
    
    while ($power > 0) {
        if ($power % 2 == 1) {
            @result = multiply_matrices(\@result, \@base);
        }
        @base = multiply_matrices(\@base, \@base);
        $power = int($power / 2);
    }
    
    return @result;
}

# Matrix multiplication
sub multiply_matrices {
    my ($a, $b) = @_;
    
    my @result = (
        [0, 0],
        [0, 0]
    );
    
    for my $i (0..1) {
        for my $j (0..1) {
            for my $k (0..1) {
                $result[$i][$j] = ($result[$i][$j] + $a->[$i][$k] * $b->[$k][$j]) % $MOD;
            }
        }
    }
    
    return @result;
}

# Simpler approach for small values to verify, then use matrix exponentiation
sub solve {
    my $n = 10**9;
    
    # Using the known recurrence relation:
    # f(n) = 4*f(n-1) - f(n-2) with f(0)=1, f(1)=3
    
    # For large n, we use matrix exponentiation
    if ($n == 0) { return 1; }
    if ($n == 1) { return 3; }
    
    # Matrix [[4, -1], [1, 0]]
    my @base = (
        [4, -1],
        [1,  0]
    );
    
    my @result = matrix_power(\@base, $n - 1);
    
    # f(n) = 3 * result[0][0] + 1 * result[0][1]
    my $answer = (3 * $result[0][0] + $result[0][1]) % $MOD;
    
    # Handle negative numbers in modular arithmetic
    if ($answer < 0) {
        $answer += $MOD;
    }
    
    return $answer;
}

# For verification with small cases:
sub verify_small_cases {
    print "Small cases verification:\n";
    print "f(0) = " . solve_small_case(0) . "\n";
    print "f(1) = " . solve_small_case(1) . "\n";
    print "f(2) = " . solve_small_case(2) . "\n";
}

sub solve_small_case {
    my $n = shift;
    
    if ($n == 0) { return 1; }
    if ($n == 1) { return 3; }
    
    # For small n, we can compute directly using the recurrence
    my $f_n_minus_2 = 1;  # f(0)
    my $f_n_minus_1 = 3;  # f(1)
    my $f_n;
    
    for my $i (2..$n) {
        $f_n = (4 * $f_n_minus_1 - $f_n_minus_2) % $MOD;
        $f_n_minus_2 = $f_n_minus_1;
        $f_n_minus_1 = $f_n;
    }
    
    return $f_n;
}

# Main execution
my $result = solve();
print "Answer to Euler Problem 508: $result\n";

# Verify with small cases
verify_small_cases();

# The final answer for 3×10^9 rectangle is:
print "The number of ways to tile a 3×10^9 rectangle with 2×1 dominoes is: $result\n";
```

```perl
#!/usr/bin/perl
use strict;
use warnings;

my $MOD = 1000000007;

# For a 3×n rectangle tiled with 2×1 dominoes, 
# the recurrence relation is f(n) = 4*f(n-1) - f(n-2)
# with f(0) = 1 and f(1) = 3

sub matrix_multiply {
    my ($a, $b) = @_;
    
    my @result = (
        [0, 0],
        [0, 0]
    );
    
    for my $i (0..1) {
        for my $j (0..1) {
            for my $k (0..1) {
                $result[$i][$j] = ($result[$i][$j] + $a->[$i][$k] * $b->[$k][$j]) % $MOD;
            }
        }
    }
    
    return @result;
}

sub matrix_power {
    my ($matrix, $power) = @_;
    
    # Identity matrix
    my @result = (
        [1, 0],
        [0, 1]
    );
    
    my @base = @$matrix;
    
    while ($power > 0) {
        if ($power % 2 == 1) {
            @result = matrix_multiply(\@result, \@base);
        }
        @base = matrix_multiply(\@base, \@base);
        $power = int($power / 2);
    }
    
    return @result;
}

sub solve_508 {
    my $n = 10**9;
    
    if ($n == 0) { return 1; }
    if ($n == 1) { return 3; }
    
    # Recurrence matrix [[4, -1], [1, 0]]
    my @matrix = (
        [4, -1],
        [1,  0]
    );
    
    my @result_matrix = matrix_power(\@matrix, $n - 1);
    
    # f(n) = 3 * result_matrix[0][0] + 1 * result_matrix[0][1]
    my $answer = (3 * $result_matrix[0][0] + $result_matrix[0][1]) % $MOD;
    
    # Handle negative results
    if ($answer < 0) {
        $answer += $MOD;
    }
    
    return $answer;
}

# Calculate and print the answer
my $answer = solve_508();
print "Answer to Euler Problem 508: $answer\n";
```

