# Euler Problem 621 Solution in Perl

## Problem Statement
Find the number of ways to write n as a sum of positive integers, where the order doesn't matter (partitions), and each part is at least 2.

## Solution

```perl
#!/usr/bin/perl
use strict;
use warnings;

sub partition_count {
    my ($n) = @_;
    
    # Create a memoization table
    my @memo = (0) x ($n + 1);
    $memo[0] = 1;
    
    # For each number from 2 to n
    for my $i (2..$n) {
        # Update the memo table from right to left
        for my $j ($i..$n) {
            $memo[$j] += $memo[$j - $i];
        }
    }
    
    return $memo[$n];
}

sub solve {
    my ($n) = @_;
    
    # We want partitions of n where each part is at least 2
    # This is equivalent to finding partitions of (n - k) where k is the number of 1's
    # But since we want each part >= 2, we can think of this as partitions of n
    # with all parts >= 2
    
    # Actually, let's reframe this: we want the number of partitions of n
    # where each part is at least 2.
    
    # This is equivalent to finding partitions of (n - k) where k is the number of 1's
    # But since we can't have 1's, we need to use a different approach.
    
    # Let's use dynamic programming directly:
    # Let dp[i][j] = number of partitions of i using parts >= j
    my @dp = ();
    for my $i (0..$n) {
        $dp[$i] = [0] x ($n + 1);
    }
    
    # Base case: 0 can be partitioned in 1 way (empty partition)
    for my $j (0..$n) {
        $dp[0][$j] = 1;
    }
    
    # Fill the DP table
    for my $i (1..$n) {
        for my $j (1..$n) {
            if ($j > $i) {
                $dp[$i][$j] = $dp[$i][$j-1];
            } else {
                $dp[$i][$j] = $dp[$i][$j-1] + $dp[$i-$j][$j];
            }
        }
    }
    
    # Return partitions of n using parts >= 2
    return $dp[$n][2];
}

# Simpler approach - direct DP for partitions with parts >= 2
sub solve_simple {
    my ($n) = @_;
    
    # dp[i][j] = number of ways to partition i using parts >= j
    my @dp = (0) x ($n + 1);
    $dp[0] = 1;
    
    # For each part size from 2 to n
    for my $part (2..$n) {
        # Update all sums that can use this part
        for my $sum ($part..$n) {
            $dp[$sum] += $dp[$sum - $part];
        }
    }
    
    return $dp[$n];
}

# Main solution
my $result = solve_simple(100);
print "The answer is: $result\n";

# For verification with smaller cases
print "Partitions of 5 with parts >= 2:\n";
my $small_result = solve_simple(5);
print "Small result (n=5): $small_result\n";

# Let's manually verify small cases
sub manual_verification {
    my ($n) = @_;
    print "Partitions of $n with parts >= 2:\n";
    
    # For small n, let's list them manually
    if ($n == 5) {
        print "5 = 5 (1 way)\n";
        print "5 = 2+3 (1 way)\n";
        print "5 = 2+2+1 (invalid - has 1)\n";
        print "Total: 2 ways\n";
    }
}

manual_verification(5);
```

Wait, let me reconsider this problem. Looking at the actual Euler problem 621 more carefully:

```perl
#!/usr/bin/perl
use strict;
use warnings;

# Euler Problem 621: Find the number of ways to write n as a sum of positive integers
# where the order doesn't matter and each part is at least 2.

# This is asking for the number of partitions of n where each part is at least 2
# We can solve this with dynamic programming

sub count_partitions_min_2 {
    my ($n) = @_;
    
    # dp[i] represents number of partitions of i where each part >= 2
    my @dp = (0) x ($n + 1);
    $dp[0] = 1;  # One way to partition 0 (empty partition)
    
    # For each possible part size from 2 to n
    for my $part (2..$n) {
        # Update all sums that can include this part
        for my $sum ($part..$n) {
            $dp[$sum] += $dp[$sum - $part];
        }
    }
    
    return $dp[$n];
}

# For the specific case of n = 100
my $result = count_partitions_min_2(100);
print "Answer: $result\n";

# Test with smaller values to verify
print "Verification:\n";
print "Partitions of 4 with parts >= 2: ";
print count_partitions_min_2(4) . "\n";  # Should be 2: 4, 2+2

print "Partitions of 5 with parts >= 2: ";
print count_partitions_min_2(5) . "\n";  # Should be 2: 5, 2+3

print "Partitions of 6 with parts >= 2: ";
print count_partitions_min_2(6) . "\n";  # Should be 3: 6, 2+4, 3+3
```

Actually, let me provide the clean final solution:

```perl
#!/usr/bin/perl
use strict;
use warnings;

sub count_partitions_min_2 {
    my ($n) = @_;
    
    # dp[i] = number of partitions of i using parts >= 2
    my @dp = (0) x ($n + 1);
    $dp[0] = 1;
    
    # For each part size from 2 to n
    for my $part (2..$n) {
        # Update all sums that can include this part
        for my $sum ($part..$n) {
            $dp[$sum] += $dp[$sum - $part];
        }
    }
    
    return $dp[$n];
}

# Calculate the answer for n = 100
my $answer = count_partitions_min_2(100);
print "The answer is: $answer\n";
```

## Explanation

This solution uses dynamic programming to count the number of partitions of a number where each part is at least 2.

1. **Initialization**: Create a DP array where `dp[i]` represents the number of ways to partition the integer `i` using parts of size at least 2.

2. **Base case**: `dp[0] = 1` because there's exactly one way to partition 0 (the empty partition).

3. **Recurrence**: For each possible part size `part` from 2 to n:
   - For each sum `sum` from `part` to n:
   - Add `dp[sum - part]` to `dp[sum]`
   - This means if we can partition `sum - part`, we can also partition `sum` by adding `part`

4. **Result**: `dp[n]` gives us the answer for the number of partitions of n with parts ≥ 2.

The time complexity is O(n²) and space complexity is O(n).

