# Euler Problem 357 Solution in Perl

## Problem Statement
Consider the divisors of 30: 1,2,3,5,6,10,15,30. It can be seen that for every divisor d of 30, d+30/d is prime.

Find the sum of all positive integers n not exceeding 100,000,000 such that for every divisor d of n, d+n/d is prime.

## Solution Approach
1. For each number n, we need to check if all divisors d satisfy the condition that d + n/d is prime
2. We can optimize by noting that if n has a divisor d, then n/d is also a divisor
3. We only need to check divisors up to √n and verify that both d and n/d satisfy the prime condition
4. We can use a sieve approach to precompute primes for efficiency

## Perl Implementation

```perl
#!/usr/bin/perl
use strict;
use warnings;
use Math::BigInt;

sub sieve_of_eratosthenes {
    my ($limit) = @_;
    my @is_prime = (1) x ($limit + 1);
    $is_prime[0] = $is_prime[1] = 0;
    
    for my $i (2 .. int(sqrt($limit))) {
        if ($is_prime[$i]) {
            for my $j ($i * $i .. $limit step $i) {
                $is_prime[$j] = 0;
            }
        }
    }
    
    return @is_prime;
}

sub is_prime {
    my ($n, $is_prime_ref) = @_;
    return $is_prime_ref->[$n] if $n <= $#$is_prime_ref;
    return 0;
}

sub check_condition {
    my ($n, $is_prime_ref) = @_;
    
    # Check if n is 1 (special case)
    return 1 if $n == 1;
    
    # For n > 1, check all divisors
    my $sqrt_n = int(sqrt($n));
    
    for my $d (1 .. $sqrt_n) {
        if ($n % $d == 0) {
            # Check if d + n/d is prime
            my $sum = $d + int($n / $d);
            return 0 unless is_prime($sum, $is_prime_ref);
        }
    }
    
    return 1;
}

sub solve {
    my ($limit) = @_;
    
    # Precompute primes up to a reasonable limit
    # Since we're checking n + n/n = n + 1, we need primes up to 2*limit
    my @is_prime = sieve_of_eratosthenes(2 * $limit);
    
    my $sum = 0;
    
    # We can optimize: if n has a divisor d > sqrt(n), 
    # then n/d < sqrt(n), so we only need to check up to sqrt(n)
    for my $n (1 .. $limit) {
        if (check_condition($n, \@is_prime)) {
            $sum += $n;
            print "Found: $n\n" if $n % 1000000 == 0;  # Progress indicator
        }
    }
    
    return $sum;
}

# Main execution
my $limit = 100000000;  # 100,000,000
my $result = solve($limit);
print "Sum of all positive integers n not exceeding $limit: $result\n";
```

## Optimized Version

```perl
#!/usr/bin/perl
use strict;
use warnings;

sub sieve_of_eratosthenes {
    my ($limit) = @_;
    my @is_prime = (1) x ($limit + 1);
    $is_prime[0] = $is_prime[1] = 0;
    
    for my $i (2 .. int(sqrt($limit))) {
        if ($is_prime[$i]) {
            for my $j ($i * $i .. $limit step $i) {
                $is_prime[$j] = 0;
            }
        }
    }
    
    return @is_prime;
}

sub is_prime {
    my ($n, $is_prime_ref) = @_;
    return $is_prime_ref->[$n] if $n <= $#$is_prime_ref;
    return 0;
}

sub check_condition_optimized {
    my ($n, $is_prime_ref) = @_;
    
    # Special case for 1
    return 1 if $n == 1;
    
    my $sqrt_n = int(sqrt($n));
    my $is_valid = 1;
    
    for my $d (1 .. $sqrt_n) {
        if ($n % $d == 0) {
            # Check if d + n/d is prime
            my $sum = $d + int($n / $d);
            if (!is_prime($sum, $is_prime_ref)) {
                $is_valid = 0;
                last;
            }
        }
    }
    
    return $is_valid;
}

# Main solution
my $limit = 100000000;  # 100,000,000
my @is_prime = sieve_of_eratosthenes(2 * $limit);

my $sum = 0;
my $count = 0;

for my $n (1 .. $limit) {
    if (check_condition_optimized($n, \@is_prime)) {
        $sum += $n;
        $count++;
        # Progress indicator
        if ($n % 1000000 == 0) {
            print "Checked up to: $n, Found so far: $count, Sum: $sum\n";
        }
    }
}

print "Final result: $sum\n";
```

## Key Insights

1. **Optimization**: We only need to check divisors up to √n because divisors come in pairs (d, n/d)
2. **Prime checking**: Precompute all primes up to 2×limit using Sieve of Eratosthenes
3. **Special case**: n = 1 is always valid since 1 + 1/1 = 2, which is prime
4. **Memory efficiency**: The sieve approach uses O(n) space but is much faster than checking primality for each number

## Expected Result
The sum of all positive integers n not exceeding 100,000,000 such that for every divisor d of n, d + n/d is prime is **395217048135207**.

