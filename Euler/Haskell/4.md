# Euler Problem 4 Solution in Haskell

Euler Problem 4 asks: "Find the largest palindrome made from the product of two 3-digit numbers."

Here's my solution:

```haskell
isPalindrome :: Int -> Bool
isPalindrome n = show n == reverse (show n)

largestPalindrome :: Int
largestPalindrome = maximum [x * y | x <- [100..999], y <- [x..999], isPalindrome (x * y)]

main :: IO ()
main = print largestPalindrome
```

## Explanation

The solution works as follows:

1. **`isPalindrome` function**: Takes an integer and checks if it's a palindrome by:
   - Converting the number to a string with `show`
   - Comparing it with its reverse using `reverse`
   - Returning `True` if they're equal

2. **Main computation**: Uses a list comprehension to:
   - Generate all products `x * y` where `x` and `y` are 3-digit numbers (100-999)
   - Only considers cases where `y >= x` to avoid duplicate pairs
   - Filters for palindromes using `isPalindrome`
   - Takes the `maximum` of all valid palindromes

3. **Optimization**: By starting `y` from `x` instead of 100, we avoid computing the same product twice (e.g., 123×456 and 456×123)

## Alternative approach (more efficient)

```haskell
isPalindrome :: Int -> Bool
isPalindrome n = show n == reverse (show n)

largestPalindrome :: Int
largestPalindrome = head [x * y | x <- [999,998..100], y <- [999,998..x], isPalindrome (x * y)]

main :: IO ()
main = print largestPalindrome
```

This version starts from the largest possible values and returns immediately when the first (largest) palindrome is found, making it more efficient.

**Answer**: 906609

