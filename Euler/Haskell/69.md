# Euler Problem 69 Solution in Haskell

Euler Problem 69 asks us to find the value of n ≤ 1,000,000 for which n/φ(n) is maximized, where φ(n) is Euler's totient function.

Let me break down the solution:

```haskell
-- Calculate Euler's totient function φ(n)
totient :: Int -> Int
totient n = n - sum [n `div` p | p <- primeFactors n]

-- Get prime factors of a number
primeFactors :: Int -> [Int]
primeFactors n = primeFactors' n 2
  where
    primeFactors' 1 _ = []
    primeFactors' n f
      | f * f > n = [n]
      | n `mod` f == 0 = f : primeFactors' (n `div` f) f
      | otherwise = primeFactors' n (f + 1)

-- Alternative more efficient approach using the formula
-- φ(n) = n * ∏(1 - 1/p) for all prime factors p of n
-- So n/φ(n) = 1 / ∏(1 - 1/p) = ∏(p/(p-1))
totientRatio :: Int -> Double
totientRatio n = product [fromIntegral p / fromIntegral (p - 1) | p <- primeFactors n]

-- Find the n that maximizes n/φ(n) for n ≤ limit
solve :: Int -> Int
solve limit = fst $ maximumBy (comparing snd) [(n, totientRatio n) | n <- [1..limit]]

-- More efficient approach using the fact that we want to maximize ∏(p/(p-1))
-- This is maximized when we include as many small primes as possible
-- So we multiply primes together until we exceed the limit
solveEfficient :: Int -> Int
solveEfficient limit = head $ takeWhile (<= limit) $ scanl (*) 1 primes
  where
    primes = sieve [2..limit]
    sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p /= 0]
    sieve [] = []

-- Even more efficient - just find the product of consecutive primes
-- until the next prime would make the product exceed the limit
solveOptimal :: Int -> Int
solveOptimal limit = product $ takeWhile (<= limit) primes
  where
    primes = sieve [2..limit]
    sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p /= 0]
    sieve [] = []

-- Final clean solution
euler69 :: Int -> Int
euler69 limit = product $ takeWhile (<= limit) [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]

-- For the specific case of limit = 1000000
main :: IO ()
main = print $ euler69 1000000
```

The key insight is that n/φ(n) is maximized when we have as many small prime factors as possible. Since φ(n) = n × ∏(1 - 1/p) for all prime factors p of n, we want to maximize the product ∏(p/(p-1)).

This is achieved by taking the product of consecutive primes starting from 2, until the product would exceed our limit.

```haskell
-- Simple and efficient solution
euler69 :: Int -> Int
euler69 limit = product $ takeWhile (<= limit) [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]

main :: IO ()
main = print $ euler69 1000000
```

**Answer: 510510**

The solution works because:
1. We want to maximize n/φ(n) = 1/(∏(1-1/p))
2. This is equivalent to minimizing ∏(1-1/p) = ∏((p-1)/p)
3. This is minimized when we include as many small primes as possible
4. The product of consecutive primes starting from 2: 2×3×5×7×11×13×17×19×23×29×31 = 232792560
5. The largest product of consecutive primes ≤ 1,000,000 is 2×3×5×7×11×13×17 = 510510

