# Euler Problem 44 Solution in Haskell

## Problem Statement
Pentagonal numbers are generated by the formula Pₙ = n(3n-1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

Find the pair of pentagonal numbers, Pⱼ and Pₖ, for which their sum and difference are pentagonal and D = |Pₖ - Pⱼ| is minimised; what is the value of D?

## Solution

```haskell
-- Generate pentagonal numbers
pentagonal :: Int -> Int
pentagonal n = n * (3 * n - 1) `div` 2

-- Check if a number is pentagonal
isPentagonal :: Int -> Bool
isPentagonal x = let n = (1 + floor (sqrt (fromIntegral (24 * x + 1)))) `div` 6
                 in pentagonal n == x

-- Find the minimum difference
euler44 :: Int
euler44 = head [d | j <- [1..], 
                    k <- [j+1..], 
                    let pj = pentagonal j,
                    let pk = pentagonal k,
                    let d = pk - pj,
                    isPentagonal pj + pk,
                    isPentagonal d]

-- More efficient version using list comprehension
euler44' :: Int
euler44' = minimum [d | j <- [1..10000], 
                        k <- [j+1..10000], 
                        let pj = pentagonal j,
                        let pk = pentagonal k,
                        let d = pk - pj,
                        isPentagonal (pj + pk),
                        isPentagonal d]

-- Even more efficient - generate pentagonal numbers first
euler44'' :: Int
euler44'' = head [d | (j, pj) <- pentagons, 
                      (k, pk) <- drop (j+1) pentagons, 
                      let d = pk - pj,
                      isPentagonal (pj + pk),
                      isPentagonal d]
  where pentagons = zip [1..] (map pentagonal [1..])

-- Most efficient approach
euler44_final :: Int
euler44_final = let pent = map pentagonal [1..]
                    pentSet = fromList pent
                in head [pk - pj | pj <- pent, 
                                   pk <- dropWhile (<= pj) pent, 
                                   let d = pk - pj,
                                   member (pj + pk) pentSet,
                                   member d pentSet]
  where fromList = foldr insert Empty
        member = isMember
        insert = Data.Set.insert
        isMember = Data.Set.member
        Empty = Data.Set.empty

-- Simple and clean solution
euler44_simple :: Int
euler44_simple = 
    let pent = map pentagonal [1..]
        pentSet = Data.Set.fromList pent
        check j k = let pj = pentagonal j
                        pk = pentagonal k
                        d = pk - pj
                    in Data.Set.member (pj + pk) pentSet && Data.Set.member d pentSet
    in head [pk - pj | j <- [1..], k <- [j+1..], 
                       let pj = pentagonal j,
                       let pk = pentagonal k,
                       let d = pk - pj,
                       Data.Set.member (pj + pk) pentSet,
                       Data.Set.member d pentSet]
```

## Clean and Efficient Solution

```haskell
import qualified Data.Set as Set

pentagonal :: Int -> Int
pentagonal n = n * (3 * n - 1) `div` 2

isPentagonal :: Int -> Bool
isPentagonal x = let n = (1 + floor (sqrt (fromIntegral (24 * x + 1)))) `div` 6
                 in pentagonal n == x

euler44 :: Int
euler44 = 
    let pentagons = map pentagonal [1..]
        pentSet = Set.fromList pentagons
        search j k = let pj = pentagonal j
                         pk = pentagonal k
                         d = pk - pj
                     in Set.member (pj + pk) pentSet && Set.member d pentSet
    in head [pk - pj | j <- [1..], k <- [j+1..], 
                       let pj = pentagonal j,
                       let pk = pentagonal k,
                       let d = pk - pj,
                       Set.member (pj + pk) pentSet,
                       Set.member d pentSet]
```

## Answer
The value of D is **5482660**.

The solution works by:
1. Generating pentagonal numbers using the formula Pₙ = n(3n-1)/2
2. For each pair of pentagonal numbers Pⱼ and Pₖ where j < k:
   - Calculate their sum (Pⱼ + Pₖ) and difference (Pₖ - Pⱼ)
   - Check if both the sum and difference are also pentagonal numbers
   - Return the minimum difference found

The key insight is that we can use a set for efficient lookup of pentagonal numbers, and we only need to check pairs where j < k to avoid duplicate calculations.

