# Euler Problem 97 Solution in Haskell

## Problem Statement
Find the last ten digits of the prime number 28433 × 2^7830457 + 1.

## Solution

```haskell
module Euler97 where

-- Function to compute (a * b) mod m efficiently
modMult :: Integer -> Integer -> Integer -> Integer
modMult a b m = (a `rem` m) * (b `rem` m) `rem` m

-- Fast modular exponentiation
modPow :: Integer -> Integer -> Integer -> Integer
modPow base 0 mod = 1
modPow base exp mod
    | even exp = modPow (modMult base base mod) (exp `div` 2) mod
    | otherwise = modMult base (modPow base (exp - 1) mod) mod

-- Main solution
solve :: Integer
solve = (28433 * modPow 2 7830457 10000000000 + 1) `rem` 10000000000

-- Alternative implementation using built-in modular exponentiation
solve' :: Integer
solve' = (28433 * (2 ^ 7830457 `mod` 10000000000) + 1) `mod` 10000000000

main :: IO ()
main = print solve
```

## Explanation

The problem asks for the last ten digits of the number 28433 × 2^7830457 + 1.

Key insights:
1. We only need the last 10 digits, so we can work modulo 10^10
2. We need to compute 2^7830457 mod 10^10 efficiently
3. We can use fast modular exponentiation to avoid computing the full number

The solution uses:
- **Fast modular exponentiation** to compute 2^7830457 mod 10^10 efficiently
- **Modular arithmetic** throughout to keep numbers manageable
- **Remainder operations** to extract only the last 10 digits

## Alternative Approach

```haskell
-- More direct approach using built-in modular exponentiation
euler97 :: Integer
euler97 = (28433 * (2 ^ 7830457 `mod` 10000000000) + 1) `mod` 10000000000

-- Even simpler using the built-in mod operator
euler97Simple :: Integer
euler97Simple = (28433 * 2^7830457 + 1) `mod` 10000000000
```

## Result

The last ten digits of 28433 × 2^7830457 + 1 are: **8739992577**

The Haskell solution efficiently handles the large exponentiation using modular arithmetic, avoiding the need to compute the full massive number.

