# Euler Problem 127 Solution in Go

## Problem Statement
The radical of n, rad(n), is the product of the distinct prime factors of n. For example, 504 = 2³ × 3² × 7, so rad(504) = 2 × 3 × 7 = 42.

We shall define the triplet (a, b, c) to be an abc-hit if:
1. gcd(a, b) = gcd(a, c) = gcd(b, c) = 1
2. a < b
3. a + b = c
4. rad(abc) < c

Find the sum of all c values for abc-hits where c < 120000.

## Solution

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    limit := 120000
    
    // Precompute prime numbers up to limit
    primes := sieveOfEratosthenes(limit)
    
    // Precompute radical values
    rad := make([]int, limit+1)
    for i := 1; i <= limit; i++ {
        rad[i] = 1
    }
    
    // Compute radical values using prime factorization
    for _, p := range primes {
        for i := p; i <= limit; i += p {
            rad[i] *= p
        }
    }
    
    // Remove duplicate prime factors
    for i := 1; i <= limit; i++ {
        temp := rad[i]
        rad[i] = 1
        for p := 2; p <= temp; p++ {
            if temp%p == 0 {
                rad[i] *= p
                for temp%p == 0 {
                    temp /= p
                }
            }
        }
    }
    
    sum := 0
    
    // Check all possible abc triplets
    for a := 1; a < limit; a++ {
        for b := a + 1; b < limit; b++ {
            c := a + b
            if c >= limit {
                break
            }
            
            // Check if gcd(a,b) = 1
            if gcd(a, b) != 1 {
                continue
            }
            
            // Check if gcd(a,c) = 1
            if gcd(a, c) != 1 {
                continue
            }
            
            // Check if gcd(b,c) = 1
            if gcd(b, c) != 1 {
                continue
            }
            
            // Check if rad(abc) < c
            abcRad := rad[a] * rad[b] * rad[c]
            if abcRad < c {
                sum += c
            }
        }
    }
    
    fmt.Printf("Sum of all c values: %d\n", sum)
}

// Sieve of Eratosthenes to find all primes up to n
func sieveOfEratosthenes(n int) []int {
    isPrime := make([]bool, n+1)
    for i := 2; i <= n; i++ {
        isPrime[i] = true
    }
    
    for i := 2; i*i <= n; i++ {
        if isPrime[i] {
            for j := i * i; j <= n; j += i {
                isPrime[j] = false
            }
        }
    }
    
    primes := []int{}
    for i := 2; i <= n; i++ {
        if isPrime[i] {
            primes = append(primes, i)
        }
    }
    
    return primes
}

// Greatest Common Divisor
func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

## Explanation

This solution works by:

1. **Precomputing primes**: Using the Sieve of Eratosthenes to find all prime numbers up to the limit.

2. **Computing radical values**: For each number, we compute its radical (product of distinct prime factors). This is done efficiently by:
   - First computing the product of all prime factors (including repetition)
   - Then removing duplicate prime factors to get the actual radical

3. **Checking all triplets**: For each valid triplet (a,b,c) where a < b and a + b = c:
   - Verify that gcd(a,b) = gcd(a,c) = gcd(b,c) = 1 (coprime condition)
   - Check if rad(abc) < c (abc-hit condition)

4. **Summing valid c values**: Add all valid c values to the running sum.

## Optimization Notes

The algorithm uses several optimizations:
- Precomputation of radical values avoids repeated prime factorization
- Early termination in loops to avoid unnecessary calculations
- Efficient GCD computation using Euclidean algorithm

The time complexity is approximately O(n log log n + n²) where n is the limit (120000), which should be efficient enough for the given constraints.

