# Euler Problem 421 Solution in JavaScript

## Problem Statement
Find the sum of all positive integers n ≤ 10^11 such that φ(n) + φ(n+1) = φ(n) × φ(n+1) where φ is Euler's totient function.

## Solution Approach
Let's analyze the equation φ(n) + φ(n+1) = φ(n) × φ(n+1).

Rearranging: φ(n) + φ(n+1) = φ(n) × φ(n+1)
This can be rewritten as: φ(n) × φ(n+1) - φ(n) - φ(n+1) = 0
Adding 1 to both sides: φ(n) × φ(n+1) - φ(n) - φ(n+1) + 1 = 1
Factoring: (φ(n) - 1) × (φ(n+1) - 1) = 1

This means that (φ(n) - 1) × (φ(n+1) - 1) = 1.

Since φ(n) and φ(n+1) are positive integers, we have:
- φ(n) - 1 = 1 and φ(n+1) - 1 = 1, which means φ(n) = 2 and φ(n+1) = 2

Let's check when φ(n) = 2:
φ(n) = 2 means n has exactly 2 numbers less than or equal to n that are coprime to n.
This happens when n is prime or n = 2.

Wait, let me reconsider this more carefully.

If (φ(n) - 1)(φ(n+1) - 1) = 1, then since both factors are integers, we need:
φ(n) - 1 = 1 and φ(n+1) - 1 = 1, which gives φ(n) = 2 and φ(n+1) = 2.

Let's think about when φ(n) = 2:
- If n = 2, then φ(2) = 1 (since only 1 is coprime to 2)
- If n = 3, then φ(3) = 2 (since 1 and 2 are coprime to 3)
- If n = 4, then φ(4) = 2 (since 1 and 3 are coprime to 4)
- If n = 6, then φ(6) = 2 (since 1 and 5 are coprime to 6)

Actually, let me reconsider the equation properly.

From φ(n) + φ(n+1) = φ(n) × φ(n+1), we get:
φ(n) + φ(n+1) - φ(n) × φ(n+1) = 0
φ(n) + φ(n+1) - φ(n) × φ(n+1) - 1 = -1
1 - φ(n) - φ(n+1) + φ(n) × φ(n+1) = -1
(1 - φ(n))(1 - φ(n+1)) = -1
(φ(n) - 1)(φ(n+1) - 1) = 1

So we need (φ(n) - 1)(φ(n+1) - 1) = 1.

This means either:
1. φ(n) - 1 = 1 and φ(n+1) - 1 = 1, so φ(n) = 2 and φ(n+1) = 2
2. φ(n) - 1 = -1 and φ(n+1) - 1 = -1, so φ(n) = 0 and φ(n+1) = 0

But φ(n) = 0 is impossible for positive integers n.

So we must have φ(n) = 2 and φ(n+1) = 2.

Now, when is φ(n) = 2?
φ(n) = 2 means n has exactly 2 numbers ≤ n that are coprime to n.

This happens when n = 3 (φ(3) = 2), n = 4 (φ(4) = 2), n = 6 (φ(6) = 2), or n = p where p is an odd prime (φ(p) = p-1, so p-1 = 2 means p = 3).

So we need n such that both n and n+1 have φ = 2.

Let's check small cases:
- n = 3: φ(3) = 2, φ(4) = 2. Check: 2 + 2 = 4 = 2 × 2. ✓
- n = 4: φ(4) = 2, φ(5) = 4. Check: 2 + 4 = 6 ≠ 8 = 2 × 4. ✗
- n = 6: φ(6) = 2, φ(7) = 6. Check: 2 + 6 = 8 ≠ 12 = 2 × 6. ✗

So n = 3 is a solution.

But let me think about this more systematically. For φ(n) = 2, we need n such that:
- n = 2^k where k ≥ 1 (but φ(2) = 1, not 2)
- n = 3 (φ(3) = 2)
- n = 4 (φ(4) = 2)  
- n = 6 (φ(6) = 2)
- n = p where p is an odd prime (φ(p) = p-1 = 2, so p = 3)

Actually, let me be more precise:
φ(n) = 2 means n is either 3, 4, 6, or a prime p where p-1 = 2, so p = 3.

So we need n such that both n and n+1 have φ = 2.

We already know that n = 3 works (φ(3) = 2, φ(4) = 2).

Let's check n = 2:
φ(2) = 1, so this doesn't work.

So we're looking for n such that:
1. φ(n) = 2 and φ(n+1) = 2

This is quite restrictive. Let me implement a solution:

```javascript
function eulerTotient(n) {
    let result = n;
    for (let i = 2; i * i <= n; i++) {
        if (n % i === 0) {
            while (n % i === 0) {
                n /= i;
            }
            result -= result / i;
        }
    }
    if (n > 1) {
        result -= result / n;
    }
    return result;
}

function solve() {
    let sum = 0;
    let limit = 100000000000; // 10^11
    
    // For small cases, we can compute directly
    for (let n = 1; n <= limit; n++) {
        let phiN = eulerTotient(n);
        let phiN1 = eulerTotient(n + 1);
        
        if (phiN + phiN1 === phiN * phiN1) {
            sum += n;
            console.log(`Found solution: n = ${n}`);
        }
        
        // For very large numbers, we'll optimize
        if (n > 1000000) {
            n += 1000000 - 1; // Skip ahead to avoid timeout
        }
    }
    
    return sum;
}

// Optimized approach for large numbers
function solveOptimized() {
    // From mathematical analysis, we can see that the only solution is n = 3
    // Let's verify this and also look for a pattern
    
    // Actually, let's think more carefully about the constraint
    // We want (φ(n) - 1)(φ(n+1) - 1) = 1
    
    // This means φ(n) - 1 = 1 and φ(n+1) - 1 = 1, so φ(n) = 2 and φ(n+1) = 2
    // This is extremely rare
    
    let sum = 0;
    let limit = 100000000000; // 10^11
    
    // Since this is very rare, let's just check a few cases
    // We know n = 3 works. Let's see if there are more.
    
    // Let's look at the mathematical structure:
    // φ(n) = 2 when n = 3, 4, 6, or n = p where p is an odd prime and p-1 = 2, so p = 3
    
    // So we need n such that both n and n+1 are in {3, 4, 6} or are primes with φ = 2
    // But if n = 3, then n+1 = 4, and φ(4) = 2. This works.
    // If n = 4, then n+1 = 5, and φ(5) = 4 ≠ 2. This doesn't work.
    // If n = 6, then n+1 = 7, and φ(7) = 6 ≠ 2. This doesn't work.
    
    // So the only solution is n = 3.
    
    // Actually, let me reconsider this more carefully by checking small cases
    // But for large numbers, we'll need to be more efficient
    
    // Let's just compute it directly for small cases and check if we can find a pattern
    let solutions = [];
    
    // We can check that for n = 3: φ(3) = 2, φ(4) = 2, so 2 + 2 = 4 = 2 × 2 ✓
    
    // Let's also check n = 1, 2, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    
    // Actually, let's compute more systematically:
    for (let n = 1; n <= 1000000; n++) {
        let phiN = eulerTotient(n);
        let phiN1 = eulerTotient(n + 1);
        
        if (phiN + phiN1 === phiN * phiN1) {
            solutions.push(n);
            console.log(`Found solution: n = ${n}, φ(${n}) = ${phiN}, φ(${n+1}) = ${phiN1}`);
        }
    }
    
    console.log("Solutions found:", solutions);
    
    // For the full range, we'd need to be much more clever
    // But based on mathematical analysis, it's likely that only n = 3 works
    return solutions.reduce((a, b) => a + b, 0);
}

// Actually, let's solve it properly using known mathematical results
function solveProblem() {
    // Mathematical analysis shows that the equation φ(n) + φ(n+1) = φ(n) × φ(n+1) 
    // is equivalent to (φ(n) - 1)(φ(n+1) - 1) = 1
    
    // This means that either:
    // 1. φ(n) - 1 = 1 and φ(n+1) - 1 = 1, which gives φ(n) = 2 and φ(n+1) = 2
    // 2. φ(n) - 1 = -1 and φ(n+1) - 1 = -1, which gives φ(n) = 0 and φ(n+1) = 0
    
    // Since φ(n) ≥ 1 for n ≥ 1, case 2 is impossible.
    
    // So we need φ(n) = 2 and φ(n+1) = 2.
    
    // When is φ(n) = 2?
    // φ(n) = 2 means n has exactly 2 positive integers ≤ n that are coprime to n.
    
    // For n = 1: φ(1) = 1
    // For n = 2: φ(2) = 1  
    // For n = 3: φ(3) = 2
    // For n = 4: φ(4) = 2
    // For n = 5: φ(5) = 4
    // For n = 6: φ(6) = 2
    // For n = 7: φ(7) = 6
    // For n = 8: φ(8) = 4
    // For n = 9: φ(9) = 6
    // For n = 10: φ(10) = 4
    
    // So n = 3, 4, 6 are the cases where φ(n) = 2.
    
    // For n = 3: φ(3) = 2, φ(4) = 2 → 2 + 2 = 4 = 2 × 2 ✓
    // For n = 4: φ(4) = 2, φ(5) = 4 → 2 + 4 = 6 ≠ 8 = 2 × 4 ✗
    // For n = 6: φ(6) = 2, φ(7) = 6 → 2 + 6 = 8 ≠ 12 = 2 × 6 ✗
    
    // Therefore, only n = 3 works.
    
    // Let's also check if there are larger solutions by computing:
    let sum = 0;
    
    // Since this is a very specific condition, and based on number theory analysis,
    // the only solution is n = 3.
    
    // But let's double-check by computing a few more values:
    let limit = 100000000000; // 10^11
    
    // For large range, we'll use the mathematical conclusion
    // But for verification, let's compute a few more cases:
    
    for (let n = 1; n <= 1000000; n++) {
        let phiN = eulerTotient(n);
        let phiN1 = eulerTotient(n + 1);
        
        if (phiN + phiN1 === phiN * phiN1) {
            sum += n;
        }
    }
    
    // Based on mathematical analysis, the answer is 3
    return sum;
}

// The correct mathematical approach:
function finalSolution() {
    // From mathematical analysis of the equation:
    // φ(n) + φ(n+1) = φ(n) × φ(n+1) 
    // This is equivalent to (φ(n) - 1)(φ(n+1) - 1) = 1
    // This means both φ(n) and φ(n+1) must equal 2
    // This happens when both n and n+1 are in {3, 4, 6} or are primes where φ = 2
    
    // Since φ(n) = 2 for n = 3, 4, 6, and only n = 3 works with n+1 = 4 (which also has φ = 2)
    
    // The only solution is n = 3
    
    return 3;
}

console.log("Solution:", finalSolution());
```

## Mathematical Analysis

The key insight is that the equation φ(n) + φ(n+1) = φ(n) × φ(n+1) can be rewritten as:
(φ(n) - 1)(φ(n+1) - 1) = 1

This means that both φ(n) and φ(n+1) must be equal to 2, since we're looking for integer solutions.

The totient function φ(n) = 2 when:
- n = 3 (since φ(3) = 2)
- n = 4 (since φ(4) = 2)  
- n = 6 (since φ(6) = 2)

For the equation to hold, we need both n and n+1 to have φ = 2.

Checking the cases:
- n = 3: φ(3) = 2, φ(4) = 2 → 2 + 2 = 4 = 2 × 2 ✓
- n = 4: φ(4) = 2, φ(5) = 4 → 2 + 4 = 6 ≠ 8 = 2 × 4 ✗
- n = 6: φ(6) = 2, φ(7) = 6 → 2 + 6 = 8 ≠ 12 = 2 × 6 ✗

Therefore, the only solution is n = 3.

## Answer

The sum of all positive integers n ≤ 10^11 such that φ(n) + φ(n+1) = φ(n) × φ(n+1) is **3**.

