# Euler Problem 668 Solution in Scala

I'll solve Euler Problem 668, which asks for the number of ways to write a number as a sum of distinct Fibonacci numbers.

## Problem Understanding

The problem asks us to find the number of ways to express a given number as a sum of distinct Fibonacci numbers, where each Fibonacci number can be used at most once.

## Approach

This is essentially a dynamic programming problem where we want to count the number of partitions of a number using distinct Fibonacci numbers. We can use the following approach:

1. Generate Fibonacci numbers up to the target
2. Use dynamic programming to count the number of ways to form each sum
3. For each Fibonacci number, we either include it or exclude it in our sum

## Solution

```scala
object Euler668 {
  
  def fibonacciCount(target: Long): Long = {
    // Generate Fibonacci numbers up to target
    val fibs = generateFibonacci(target)
    
    // dp[i] represents number of ways to form sum i
    val dp = new Array[Long](target.toInt + 1)
    dp(0) = 1 // One way to form 0 (use nothing)
    
    // For each Fibonacci number, update the dp array
    for (fib <- fibs) {
      // Traverse backwards to avoid using the same Fibonacci number multiple times
      for (i <- target.toInt downTo fib.toInt) {
        dp(i) += dp(i - fib.toInt)
      }
    }
    
    dp(target.toInt)
  }
  
  def generateFibonacci(limit: Long): List[Long] = {
    var a = 1L
    var b = 1L
    val fibs = scala.collection.mutable.ListBuffer[Long]()
    
    while (a <= limit) {
      fibs += a
      val temp = a + b
      a = b
      b = temp
    }
    
    fibs.toList
  }
  
  def main(args: Array[String]): Unit = {
    // For demonstration, let's test with a smaller example
    println("Number of ways to express 10 as sum of distinct Fibonacci numbers:")
    println(fibonacciCount(10))
    
    // For the actual problem, we would compute for a specific target
    // The problem likely asks for a specific value
    println("Solution for Euler 668:")
    println(fibonacciCount(1000000000000L)) // This would be the actual target
  }
}

// Alternative implementation using a more functional approach
object Euler668Functional {
  
  def countWays(target: Long): Long = {
    val fibs = generateFibonacci(target)
    
    // Memoization using a map
    val memo = scala.collection.mutable.Map[Int, Long]()
    
    def countWaysHelper(remaining: Long, fibIndex: Int): Long = {
      if (remaining == 0) return 1
      if (remaining < 0 || fibIndex >= fibs.length) return 0
      
      val key = (remaining.toInt, fibIndex)
      if (memo.contains(key)) return memo(key)
      
      // Either include current Fibonacci number or exclude it
      val include = countWaysHelper(remaining - fibs(fibIndex), fibIndex + 1)
      val exclude = countWaysHelper(remaining, fibIndex + 1)
      
      val result = include + exclude
      memo(key) = result
      result
    }
    
    countWaysHelper(target, 0)
  }
  
  def generateFibonacci(limit: Long): List[Long] = {
    def fibHelper(a: Long, b: Long, acc: List[Long]): List[Long] = {
      if (a > limit) acc.reverse
      else fibHelper(b, a + b, a :: acc)
    }
    
    fibHelper(1, 1, List())
  }
  
  def main(args: Array[String]): Unit = {
    println("Functional approach result:")
    println(countWays(1000000000000L))
  }
}
```

## Explanation

The solution uses dynamic programming to count the number of ways to express a number as a sum of distinct Fibonacci numbers:

1. **Fibonacci Generation**: First, we generate all Fibonacci numbers up to our target value.

2. **Dynamic Programming Approach**: 
   - We create a `dp` array where `dp[i]` represents the number of ways to form sum `i`
   - Initially, `dp[0] = 1` (one way to form 0: use no numbers)
   - For each Fibonacci number, we update our dp array from right to left to ensure we don't use the same Fibonacci number multiple times

3. **Transition Logic**: For each Fibonacci number, we have two choices:
   - Include it: `dp[i] += dp[i - fib]`
   - Exclude it: `dp[i]` remains unchanged

## Time and Space Complexity

- **Time Complexity**: O(target × number of Fibonacci numbers) = O(target × log(target))
- **Space Complexity**: O(target)

## Key Insights

1. The problem is essentially counting partitions with distinct elements (Fibonacci numbers)
2. We use the "unbounded knapsack" pattern but with the constraint that each item (Fibonacci number) can be used at most once
3. The Fibonacci sequence grows exponentially, so the number of Fibonacci numbers up to N is approximately log(N)

The solution efficiently handles the constraint that each Fibonacci number can only be used once, making it a classic dynamic programming problem with a twist on the standard subset sum approach.

