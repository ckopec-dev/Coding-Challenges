# Euler Problem 144 Solution in Scala

This problem involves finding the number of reflections a laser beam makes before exiting an elliptical mirror system.

```scala
object Euler144 {
  case class Point(x: Double, y: Double)
  
  // Ellipse equation: x²/16 + y²/9 = 1
  // Standard form: x²/a² + y²/b² = 1 where a = 4, b = 3
  val a = 4.0
  val b = 3.0
  
  // Calculate the slope of the tangent at a point on the ellipse
  def tangentSlope(p: Point): Double = {
    // For ellipse x²/a² + y²/b² = 1, tangent slope at (x,y) is -b²x/a²y
    -(b * b * p.x) / (a * a * p.y)
  }
  
  // Calculate the normal slope at a point (perpendicular to tangent)
  def normalSlope(p: Point): Double = {
    // Normal is perpendicular to tangent
    -1.0 / tangentSlope(p)
  }
  
  // Reflect a direction vector across a normal vector
  def reflect(direction: Point, normal: Point): Point = {
    // Using reflection formula: R = D - 2(D·N)N
    val dotProduct = direction.x * normal.x + direction.y * normal.y
    val reflectedX = direction.x - 2 * dotProduct * normal.x
    val reflectedY = direction.y - 2 * dotProduct * normal.y
    Point(reflectedX, reflectedY)
  }
  
  // Find intersection point of ray with ellipse
  def intersectRayEllipse(start: Point, direction: Point): Option[Point] = {
    // Ray: P(t) = start + t * direction
    // Ellipse: x²/a² + y²/b² = 1
    
    val dx = direction.x
    val dy = direction.y
    val sx = start.x
    val sy = start.y
    
    // Substitute ray equation into ellipse equation
    // (sx + t*dx)²/a² + (sy + t*dy)²/b² = 1
    // This gives us a quadratic equation: At² + Bt + C = 0
    
    val A = (dx * dx) / (a * a) + (dy * dy) / (b * b)
    val B = 2 * (sx * dx) / (a * a) + 2 * (sy * dy) / (b * b)
    val C = (sx * sx) / (a * a) + (sy * sy) / (b * b) - 1
    
    val discriminant = B * B - 4 * A * C
    
    if (discriminant < 0) None
    else {
      val sqrtDiscriminant = math.sqrt(discriminant)
      val t1 = (-B + sqrtDiscriminant) / (2 * A)
      val t2 = (-B - sqrtDiscriminant) / (2 * A)
      
      // We want the first intersection point (smallest positive t)
      val t = if (t1 > 0 && t2 > 0) math.min(t1, t2) else 
              if (t1 > 0) t1 else t2
      
      if (t > 0) Some(Point(sx + t * dx, sy + t * dy))
      else None
    }
  }
  
  def solve(): Int = {
    val start = Point(0.0, 10.1)
    val direction = Point(1.4, -0.1) // Initial direction vector
    
    var currentPoint = start
    var currentDirection = direction
    var reflections = 0
    
    // Continue until the beam exits through the hole at (0, 10)
    while (true) {
      // Find next intersection point
      val intersection = intersectRayEllipse(currentPoint, currentDirection)
      
      intersection match {
        case Some(point) =>
          // Check if we've exited through the hole
          if (math.abs(point.x) < 0.01 && math.abs(point.y - 10.0) < 0.01) {
            return reflections
          }
          
          // Calculate normal at intersection point
          val normal = Point(point.x, point.y) // Normal vector points inward
          val normalSlopeVal = normalSlope(point)
          
          // The normal vector for reflection
          val normalVector = Point(1.0, normalSlopeVal)
          val normalMagnitude = math.sqrt(1.0 + normalSlopeVal * normalSlopeVal)
          val normalizedNormal = Point(normalVector.x / normalMagnitude, 
                                     normalVector.y / normalMagnitude)
          
          // Reflect the direction
          currentDirection = reflect(currentDirection, normalizedNormal)
          currentPoint = point
          reflections += 1
          
        case None => return reflections // No intersection found
      }
    }
    
    reflections
  }
  
  def main(args: Array[String]): Unit = {
    println(s"Number of reflections: ${solve()}")
  }
}
```

The solution works by:

1. **Modeling the ellipse**: Using the standard form x²/16 + y²/9 = 1 where a = 4 and b = 3
2. **Calculating tangent and normal slopes**: Using calculus to find the slope at any point on the ellipse
3. **Ray intersection**: Solving the quadratic equation to find where a ray intersects the ellipse
4. **Reflection physics**: Using vector reflection formula to calculate the new direction after each bounce
5. **Exit condition**: Continuing until the beam exits through the hole at (0, 10)

The key insight is that each reflection follows the law of reflection where the angle of incidence equals the angle of reflection with respect to the normal vector.

