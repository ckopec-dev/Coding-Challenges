# Euler Problem 14 Solution in Scala

## Problem Statement
The following iterative sequence is defined for the set of positive integers:
- n → n/2 (n is even)
- n → 3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

The sequence has 10 terms. Which starting number under one million produces the longest chain?

## Solution

```scala
object Euler14 {
  def main(args: Array[String]): Unit = {
    val result = (1 until 1000000)
      .map(n => (n, collatzLength(n)))
      .maxBy(_._2)
    
    println(s"Starting number: ${result._1}")
    println(s"Chain length: ${result._2}")
  }
  
  def collatzLength(n: Long): Long = {
    @annotation.tailrec
    def helper(current: Long, count: Long): Long = {
      if (current == 1) count
      else if (current % 2 == 0) helper(current / 2, count + 1)
      else helper(3 * current + 1, count + 1)
    }
    
    helper(n, 1)
  }
}
```

## Alternative Solution with Memoization

```scala
import scala.collection.mutable

object Euler14Memoized {
  val cache = mutable.Map[Long, Long]()
  
  def main(args: Array[String]): Unit = {
    cache.put(1, 1)
    
    val result = (1 until 1000000)
      .map(n => (n, collatzLength(n)))
      .maxBy(_._2)
    
    println(s"Starting number: ${result._1}")
    println(s"Chain length: ${result._2}")
  }
  
  def collatzLength(n: Long): Long = {
    cache.get(n) match {
      case Some(value) => value
      case None =>
        val length = if (n % 2 == 0) 
          1 + collatzLength(n / 2)
        else 
          1 + collatzLength(3 * n + 1)
        
        cache.put(n, length)
        length
    }
  }
}
```

## Explanation

The solution works by:

1. **Brute Force Approach**: For each number from 1 to 999,999, we calculate the Collatz sequence length
2. **Tail Recursive Helper**: The `collatzLength` function uses tail recursion to efficiently compute the sequence length
3. **Finding Maximum**: We use `maxBy` to find the starting number that produces the longest chain

## Key Features

- **Tail Recursion**: The helper function is tail-recursive for efficiency
- **Immutable Data**: Uses functional programming concepts
- **Performance**: The memoized version caches previously computed results to avoid redundant calculations

## Result

The starting number under one million that produces the longest Collatz chain is **837799** with a chain length of **525** terms.

The memoized version is significantly faster for larger computations as it avoids recalculating the same sequence lengths multiple times.

