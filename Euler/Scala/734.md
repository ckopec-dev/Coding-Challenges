# Euler Problem 734 Solution in Scala

Let me solve this step by step.

First, let me understand what the problem is asking:
- We need to find the sum of all positive integers n ≤ 10^16 that have exactly 2017 divisors
- This requires understanding the relationship between divisors and prime factorization

## Analysis

For a number n with prime factorization n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, the number of divisors is:
d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1)

We need d(n) = 2017.

Since 2017 is prime, we have two cases:
1. n = p^2016 for some prime p (since 2016 + 1 = 2017)
2. n = p₁^a₁ × p₂^a₂ where (a₁ + 1)(a₂ + 1) = 2017

Since 2017 is prime, the only factorizations are:
- 2017 = 1 × 2017
- 2017 = 2017 × 1

This means we can have either:
- n = p^2016 (where p is prime) 
- n = p₁^2016 × p₂^0 = p₁^2016 (which is the same as case 1)

Wait, let me reconsider. If d(n) = 2017 and 2017 is prime, then we need to express 2017 as a product of integers > 1 in all possible ways.

Actually, since 2017 is prime, the only way to write it as a product of factors ≥ 2 is 2017 = 2017 × 1.

So we can have:
- n = p^2016 (where p is prime)  
- n = p₁^a₁ × p₂^a₂ where (a₁ + 1)(a₂ + 1) = 2017

Since 2017 is prime, this means either:
- a₁ + 1 = 2017 and a₂ + 1 = 1, so a₁ = 2016 and a₂ = 0
- a₁ + 1 = 1 and a₂ + 1 = 2017, so a₁ = 0 and a₂ = 2016

This gives us the same case: n = p^2016 for some prime p.

Wait, that's not right. I'm misreading the problem.

Let me reconsider what "exactly 2017 divisors" means. The number of positive divisors of n.

If d(n) = 2017, and since 2017 is prime, we need to find all ways to write 2017 as a product of integers ≥ 2.

But actually, for the divisor function, if n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, then d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1).

Since 2017 is prime, we have two cases:
1. n = p^2016 for some prime p (since 2016 + 1 = 2017)
2. n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ such that (a₁ + 1)(a₂ + 1)...(aₖ + 1) = 2017

Since 2017 is prime, we can only have:
- One factor: n = p^2016  
- Two factors with one being 1: this means we're back to case 1

But actually, we need to be more careful. The product (a₁ + 1)(a₂ + 1)...(aₖ + 1) = 2017.

Since 2017 is prime:
- Either k=1 and a₁ = 2016
- Or the factors are all 1, but that would mean a₁ = a₂ = ... = 0, which gives n = 1

So we only have n = p^2016 for some prime p.

Wait, let me re-read more carefully. 

Actually, let's think about this systematically:
If n has exactly 2017 divisors, and d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1) = 2017

Since 2017 is prime, the only way to factorize it is 2017 = 2017 × 1.

This means we can have:
- One prime power: n = p^2016 (since 2016 + 1 = 2017)
- The case where we have multiple prime powers but their exponents+1 multiply to 2017

But since 2017 is prime, the only valid way is:
(a₁ + 1) = 2017 and (a₂ + 1) = (a₃ + 1) = ... = (aₖ + 1) = 1

This means a₁ = 2016 and a₂ = a₃ = ... = aₖ = 0.

So n = p^2016 for some prime p.

## Solution Approach

We need to find all primes p such that p^2016 ≤ 10^16.

Taking logarithms: 2016 × log(p) ≤ 16 × log(10)

Therefore: log(p) ≤ (16 × log(10)) / 2016

Let's implement this in Scala:

```scala
object Euler734 {
  def main(args: Array[String]): Unit = {
    val limit = 10L.pow(16)
    val exponent = 2016
    
    // Find all primes p such that p^2016 <= 10^16
    val primes = sieveOfEratosthenes(1000000) // Generate enough primes
    
    val result = primes.takeWhile(p => {
      val power = Math.pow(p, exponent)
      power <= limit
    }).map(p => Math.pow(p, exponent).toLong).sum
    
    println(result)
  }
  
  def sieveOfEratosthenes(limit: Int): List[Int] = {
    val isPrime = Array.fill(limit + 1)(true)
    isPrime(0) = isPrime(1) = false
    
    for (i <- 2 to math.sqrt(limit).toInt) {
      if (isPrime(i)) {
        var j = i * i
        while (j <= limit) {
          isPrime(j) = false
          j += i
        }
      }
    }
    
    (2 to limit).filter(isPrime(_)).toList
  }
}
```

But let me reconsider the mathematical constraint more carefully.

We need p^2016 ≤ 10^16, so p ≤ (10^16)^(1/2016) = 10^(16/2016) = 10^(1/126).

10^(1/126) ≈ 1.018

This means we only need to consider p = 2, since we're looking for primes.

But wait, that's not right either. Let me compute this more carefully:

10^16 = 10000000000000000
(10^16)^(1/2016) = 10^(16/2016) ≈ 1.018

This means p ≤ 1.018, so the only prime is p = 2.

But let's double-check that 2^2016 ≤ 10^16:
- 2^10 = 1024
- 2^20 = (2^10)^2 = 1024^2 = 1,048,576
- 2^40 = (2^20)^2 ≈ 1.09 × 10^12  
- 2^80 = (2^40)^2 ≈ 1.19 × 10^24

So 2^2016 is much larger than 10^16.

Let me reconsider: we're looking for p such that p^2016 ≤ 10^16.

Taking logarithms:
2016 × log(p) ≤ 16 × log(10)

So log(p) ≤ 16/2016 = 1/126

Since 1/126 ≈ 0.007937, we have p ≤ e^(0.007937) ≈ 1.00795.

So there are no primes p > 1 satisfying this condition!

Wait, let me double-check that 2017 is indeed prime and reconsider the approach:

Actually, I think I made an error in the mathematical reasoning. Let me recheck what 2017 factors as.

Let me check if 2017 is prime:
- Not divisible by 2 (odd)
- Sum of digits: 2+0+1+7 = 10 (not divisible by 3)  
- Doesn't end in 0 or 5
- √2017 ≈ 45

Check divisibility by primes up to 45:
- 2017 ÷ 7 = 288.14... 
- 2017 ÷ 11 = 183.36...
- 2017 ÷ 13 = 155.15...
- 2017 ÷ 17 = 118.65...
- 2017 ÷ 19 = 106.16...
- 2017 ÷ 23 = 87.69...
- 2017 ÷ 29 = 69.55...
- 2017 ÷ 31 = 65.06...
- 2017 ÷ 37 = 54.51...
- 2017 ÷ 41 = 49.19...
- 2017 ÷ 43 = 46.90...

So 2017 is indeed prime.

But let's reconsider the problem setup more carefully. 

We have d(n) = 2017 where d(n) is the number of positive divisors of n.

This means if n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, then:
(a₁ + 1)(a₂ + 1)...(aₖ + 1) = 2017

Since 2017 is prime, the only way to write it as a product of integers ≥ 2 is:
- (a₁ + 1) = 2017 and all other (aᵢ + 1) = 1
- This means a₁ = 2016 and a₂ = a₃ = ... = aₖ = 0

So n = p^2016 for some prime p.

But now the constraint is p^2016 ≤ 10^16.

Let's compute this properly:
p^2016 ≤ 10^16
p ≤ (10^16)^(1/2016) = 10^(16/2016) = 10^(1/126)

10^(1/126) ≈ 1.00795

This means no prime p > 1 satisfies the condition.

However, I think there might be an issue with my interpretation of "exactly 2017 divisors". 

Let me re-read the problem statement...

Actually, let's look at it more carefully. The number of divisors is:
d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1)

If d(n) = 2017 and we're looking for the sum of all such n ≤ 10^16, then indeed only n = p^2016 is possible.

But since p^2016 > 10^16 for any prime p ≥ 2, we only consider p = 2.

So n = 2^2016. 

But let's compute this:
2^2016 = (2^10)^201.6 = 1024^201.6

This is much larger than 10^16, so the only possibility would be n = 1.

Wait, n = 1 has exactly 1 divisor, not 2017.

So there are no such numbers with exactly 2017 divisors that are ≤ 10^16.

But let's double-check: d(1) = 1.

I think I need to reconsider if there could be other factorizations of 2017.

Actually, wait - what about cases like n = p₁^a₁ × p₂^a₂ such that (a₁ + 1)(a₂ + 1) = 2017?

But since 2017 is prime, we must have either:
- a₁ + 1 = 1 and a₂ + 1 = 2017 → a₁ = 0, a₂ = 2016
- a₁ + 1 = 2017 and a₂ + 1 = 1 → a₁ = 2016, a₂ = 0

These both reduce to n = p^2016.

So we're back to the same conclusion. 

But let me compute the actual value:
2^2016 vs 10^16

log₂(10^16) = 16 × log₂(10) ≈ 16 × 3.32 ≈ 53.1

Since 2016 > 53.1, we have 2^2016 >> 10^16.

Therefore, there are no such numbers n ≤ 10^16 with exactly 2017 divisors.

Wait, let me also consider the case where a₁ = 0, meaning we don't include that prime factor. So we're looking for numbers of the form p^2016.

Let's actually code this up:

```scala
object Euler734 {
  def main(args: Array[String]): Unit = {
    val limit = 10L.pow(16)
    val exponent = 2016
    
    // Find primes p such that p^2016 <= 10^16
    // We only need to check primes up to the maximum value such that p^2016 <= 10^16
    val maxPrime = Math.pow(10.0, 16.0 / 2016.0).toInt + 1
    
    // Generate all primes up to maxPrime using sieve
    val primes = sieveOfEratosthenes(maxPrime)
    
    // Find all valid n = p^2016 where p^2016 <= 10^16
    val validNumbers = primes.filter { p =>
      val power = Math.pow(p.toDouble, exponent)
      power <= limit
    }.map(p => Math.pow(p.toDouble, exponent).toLong)
    
    println(validNumbers.sum)
  }
  
  def sieveOfEratosthenes(limit: Int): List[Int] = {
    if (limit < 2) return List.empty
    
    val isPrime = Array.fill(limit + 1)(true)
    isPrime(0) = isPrime(1) = false
    
    for (i <- 2 to math.sqrt(limit).toInt) {
      if (isPrime(i)) {
        var j = i * i
        while (j <= limit) {
          isPrime(j) = false
          j += i
        }
      }
    }
    
    (2 to limit).filter(isPrime(_)).toList
  }
}
```

Let me compute the actual value:
16/2016 ≈ 0.007937
10^0.007937 ≈ 1.018

So we only need to check primes up to about 1.018, which means only p = 2.

But we already know 2^2016 is much larger than 10^16.

Let me just code it properly:

```scala
object Euler734 {
  def main(args: Array[String]): Unit = {
    val limit = 10L.pow(16)
    val exponent = 2016
    
    // Since we're looking for n = p^2016 <= 10^16,
    // we need p <= (10^16)^(1/2016) = 10^(16/2016)
    
    val maxP = Math.pow(10.0, 16.0 / 2016.0).toInt + 1
    
    // Generate all primes up to maxP
    val primes = sieveOfEratosthenes(maxP)
    
    // Find valid numbers n = p^2016 where p^2016 <= 10^16
    var sum = 0L
    for (p <- primes) {
      val power = Math.pow(p.toDouble, exponent)
      if (power <= limit) {
        sum += power.toLong
      } else {
        // Since primes are increasing and p^2016 is increasing,
        // no larger prime will work either
        // break
      }
    }
    
    println(sum)
  }
  
  def sieveOfEratosthenes(limit: Int): List[Int] = {
    if (limit < 2) return List.empty
    
    val isPrime = Array.fill(limit + 1)(true)
    isPrime(0) = isPrime(1) = false
    
    for (i <- 2 to math.sqrt(limit).toInt) {
      if (isPrime(i)) {
        var j = i * i
        while (j <= limit) {
          isPrime(j) = false
          j += i
        }
      }
    }
    
    (2 to limit).filter(isPrime(_)).toList
  }
}
```

Computing 10^(16/2016):
16/2016 ≈ 0.007937
10^0.007937 ≈ 1.018

So max prime to check is around 1, which means only p = 2 would be considered.

But 2^2016 >> 10^16, so no valid numbers exist.

The answer should be 0.

But let's reconsider - perhaps I misread the problem or there's a different interpretation.

Let me try with Python to double-check:

```python
import math

limit = 10**16
exponent = 2016

# Calculate maximum prime we need to check
max_p = int(10**(16/2016)) + 1
print(f"max_p: {max_p}")

# Check if any p^2016 <= 10^16
p = 2
while p <= max_p:
    power = p**exponent
    if power <= limit:
        print(f"{p}^{exponent} = {power}")
    else:
        break
    p += 1

# Actually, let's compute it directly
print("10^(16/2016) =", 10**(16/2016))
```

Actually, I think the mathematical analysis is correct: since 2016 is much larger than 16, and we're taking powers, there are no such numbers.

But for completeness, here's a full implementation:

```scala
object Euler734 {
  def main(args: Array[String]): Unit = {
    val limit = 10L.pow(16)
    val exponent = 2016
    
    // Since p^2016 <= 10^16, we have p <= (10^16)^(1/2016) = 10^(16/2016)
    val maxP = Math.pow(10.0, 16.0 / 2016.0).toInt + 1
    
    // Generate primes up to maxP
    val primes = sieveOfEratosthenes(maxP)
    
    // Find valid n = p^2016 where p^2016 <= 10^16
    var sum = 0L
    for (p <- primes) {
      val power = Math.pow(p.toDouble, exponent)
      if (power <= limit) {
        sum += power.toLong
      } else {
        // Since powers increase with increasing p, no larger p will work
        // break
      }
    }
    
    println(sum)
  }
  
  def sieveOfEratosthenes(limit: Int): List[Int] = {
    if (limit < 2) return List.empty
    
    val isPrime = Array.fill(limit + 1)(true)
    isPrime(0) = isPrime(1) = false
    
    for (i <- 2 to math.sqrt(limit).toInt) {
      if (isPrime(i)) {
        var j = i * i
        while (j <= limit) {
          isPrime(j) = false
          j += i
        }
      }
    }
    
    (2 to limit).filter(isPrime(_)).toList
  }
}
```

After careful analysis, the answer is 0. There are no positive integers n ≤ 10^16 such that n has exactly 2017 divisors.

**Final Answer: 0**

