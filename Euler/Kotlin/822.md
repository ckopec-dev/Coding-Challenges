# Euler Problem 822 Solution in Kotlin

I'll solve Euler Problem 822, which asks for the sum of all positive integers n ≤ 10^12 such that n is divisible by 3 and n can be written as the sum of two positive perfect squares.

Let me break down the approach:

1. We need to find numbers n ≤ 10^12 where n ≡ 0 (mod 3) and n = a² + b² for positive integers a, b
2. We'll iterate through possible values and check the conditions
3. We need to be efficient to handle the large constraint of 10^12

```kotlin
import kotlin.math.*

fun main() {
    val limit = 1_000_000_000_000L
    val result = solve(limit)
    println("Result: $result")
}

fun solve(limit: Long): Long {
    var sum = 0L
    val sqrtLimit = sqrt(limit.toDouble()).toLong()
    
    // For each possible value of a
    for (a in 1..sqrtLimit) {
        val aSquared = a * a
        // Skip if a² is already divisible by 3 (since n must be divisible by 3)
        if (aSquared % 3 == 0) continue
        
        // For each possible value of b
        for (b in 1..sqrtLimit) {
            val n = aSquared + b * b
            
            // Break if n exceeds limit
            if (n > limit) break
            
            // Check if n is divisible by 3
            if (n % 3 == 0) {
                sum += n
            }
        }
    }
    
    return sum
}
```

Wait, let me reconsider this approach. There's a mathematical insight I should use.

Actually, let me think more carefully about the mathematical properties:

1. If n = a² + b² and n ≡ 0 (mod 3), then we need to analyze when this is possible
2. For squares modulo 3: 0² ≡ 0, 1² ≡ 1, 2² ≡ 1 (mod 3)
3. So a² + b² ≡ 0 (mod 3) if and only if both a² ≡ 0 (mod 3) and b² ≡ 0 (mod 3)
4. This means both a and b must be divisible by 3

Let me revise the solution:

```kotlin
import kotlin.math.*

fun main() {
    val limit = 1_000_000_000_000L
    val result = solve(limit)
    println("Result: $result")
}

fun solve(limit: Long): Long {
    var sum = 0L
    val sqrtLimit = sqrt(limit.toDouble()).toLong()
    
    // Since both a and b must be divisible by 3 for n = a² + b² to be divisible by 3
    // We only check multiples of 3
    val maxA = sqrtLimit
    
    // For each multiple of 3 (a = 3k)
    for (a in 3..maxA step 3) {
        val aSquared = a * a
        
        // For each multiple of 3 (b = 3k)  
        for (b in 3..maxA step 3) {
            val n = aSquared + b * b
            
            if (n > limit) break
            
            if (n % 3 == 0) {
                sum += n
            }
        }
    }
    
    return sum
}
```

Actually, I'm overcomplicating this. Let me think even more carefully.

The key insight is that we want n = a² + b² where n ≡ 0 (mod 3). 

If a ≡ 0 (mod 3) and b ≡ 0 (mod 3), then a² ≡ 0 (mod 3) and b² ≡ 0 (mod 3), so n ≡ 0 (mod 3).
If a ≢ 0 (mod 3) and b ≢ 0 (mod 3), then a² ≡ 1 (mod 3) and b² ≡ 1 (mod 3), so n ≡ 2 (mod 3).
If exactly one of a, b is divisible by 3, then n ≡ 1 (mod 3).

So for n to be divisible by 3, both a and b must be divisible by 3.

Here's the correct solution:

```kotlin
fun main() {
    val limit = 1_000_000_000_000L
    val result = solve(limit)
    println("Result: $result")
}

fun solve(limit: Long): Long {
    var sum = 0L
    val sqrtLimit = sqrt(limit.toDouble()).toLong()
    
    // Since both a and b must be divisible by 3 for n = a² + b² to be divisible by 3
    val maxA = sqrtLimit
    
    // For each multiple of 3 (a = 3k)
    for (a in 3..maxA step 3) {
        val aSquared = a * a
        
        // For each multiple of 3 (b = 3k)  
        for (b in 3..maxA step 3) {
            val n = aSquared + b * b
            
            if (n > limit) break
            
            sum += n
        }
    }
    
    return sum
}
```

But this approach is still inefficient. Let me optimize it:

```kotlin
fun main() {
    val limit = 1_000_000_000_000L
    val result = solve(limit)
    println("Result: $result")
}

fun solve(limit: Long): Long {
    var sum = 0L
    val sqrtLimit = sqrt(limit.toDouble()).toLong()
    
    // Since we need n = a² + b² where n is divisible by 3
    // Both a and b must be divisible by 3
    val maxA = sqrtLimit
    
    for (a in 3..maxA step 3) {
        val aSquared = a * a
        val maxB = sqrt((limit - aSquared).toDouble()).toLong()
        
        for (b in 3..maxB step 3) {
            val n = aSquared + b * b
            if (n <= limit) {
                sum += n
            } else {
                break
            }
        }
    }
    
    return sum
}
```

