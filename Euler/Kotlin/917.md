# Euler Problem 917 Solution in Kotlin

I'll solve Euler Problem 917, which asks for the number of ways to write a number as a sum of powers of 2, where each power can be used at most twice.

## Problem Understanding

We need to find the number of ways to express a given number as a sum of powers of 2 (1, 2, 4, 8, 16, ...), where each power can be used at most twice.

This is essentially a dynamic programming problem where we count the number of representations.

## Solution Approach

I'll use dynamic programming with memoization:
- For each number, we can either use 0, 1, or 2 of each power of 2
- We'll recursively calculate the number of ways to represent each number
- Memoize results to avoid recomputation

## Kotlin Implementation

```kotlin
import java.util.*

fun main() {
    val result = countWays(1000000)
    println("Answer: $result")
}

fun countWays(n: Int): Long {
    val memo = mutableMapOf<Int, Long>()
    return countWaysHelper(n, 1, memo)
}

fun countWaysHelper(n: Int, power: Int, memo: MutableMap<Int, Long>): Long {
    // Base case: if n is 0, we found one way (using nothing)
    if (n == 0) return 1L
    
    // Base case: if n is negative or power is too large, no way
    if (n < 0 || power > n) return 0L
    
    // Check if already computed
    val key = n * 1000000 + power // Simple key generation
    if (memo.containsKey(key)) {
        return memo[key]!!
    }
    
    // We can use 0, 1, or 2 of the current power
    val ways = countWaysHelper(n, power * 2, memo) +  // Use 0 of current power
               countWaysHelper(n - power, power * 2, memo) +  // Use 1 of current power
               countWaysHelper(n - 2 * power, power * 2, memo)  // Use 2 of current power
    
    memo[key] = ways
    return ways
}

// Alternative more efficient approach using iterative DP
fun countWaysIterative(n: Int): Long {
    val dp = LongArray(n + 1) { 0L }
    dp[0] = 1L
    
    var power = 1
    while (power <= n) {
        // For each power, update dp array
        for (i in power..n) {
            // We can use 0, 1, or 2 of current power
            dp[i] += dp[i - power]  // Use 1 of current power
            if (i >= 2 * power) {
                dp[i] += dp[i - 2 * power]  // Use 2 of current power
            }
        }
        power *= 2
    }
    
    return dp[n]
}
```

Wait, let me reconsider this more carefully. Looking at the problem again, I realize I need to be more precise about the approach.

Let me revise the solution:

```kotlin
import kotlin.math.*

fun main() {
    val result = countWays(1000000)
    println("Answer: $result")
}

fun countWays(n: Int): Long {
    val memo = mutableMapOf<Pair<Int, Int>, Long>()
    return countWaysHelper(n, 0, memo)
}

fun countWaysHelper(n: Int, powerIndex: Int, memo: MutableMap<Pair<Int, Int>, Long>): Long {
    // Base case: if n is 0, we found one way
    if (n == 0) return 1L
    
    // Base case: if n is negative or we've gone too far
    if (n < 0) return 0L
    
    val key = Pair(n, powerIndex)
    if (memo.containsKey(key)) {
        return memo[key]!!
    }
    
    val power = 1 shl powerIndex  // 2^powerIndex
    
    // If current power is greater than n, we can't use it
    if (power > n) {
        memo[key] = 0L
        return 0L
    }
    
    // We can use 0, 1, or 2 of the current power
    val ways = countWaysHelper(n, powerIndex + 1, memo) +  // Use 0 of current power
               countWaysHelper(n - power, powerIndex + 1, memo) +  // Use 1 of current power
               countWaysHelper(n - 2 * power, powerIndex + 1, memo)  // Use 2 of current power
    
    memo[key] = ways
    return ways
}

// More efficient iterative solution
fun countWaysEfficient(n: Int): Long {
    val dp = LongArray(n + 1) { 0L }
    dp[0] = 1L
    
    var power = 1
    while (power <= n) {
        for (i in power..n) {
            dp[i] += dp[i - power]  // Use 1 of current power
            if (i >= 2 * power) {
                dp[i] += dp[i - 2 * power]  // Use 2 of current power
            }
        }
        power *= 2
    }
    
    return dp[n]
}
```

## Final Solution

```kotlin
fun main() {
    val result = countWaysEfficient(1000000)
    println("Answer: $result")
}

fun countWaysEfficient(n: Int): Long {
    val dp = LongArray(n + 1) { 0L }
    dp[0] = 1L
    
    var power = 1
    while (power <= n) {
        for (i in power..n) {
            dp[i] += dp[i - power]  // Use 1 of current power
            if (i >= 2 * power) {
                dp[i] += dp[i - 2 * power]  // Use 2 of current power
            }
        }
        power *= 2
    }
    
    return dp[n]
}
```

## Explanation

The solution uses dynamic programming with the following approach:

1. **DP State**: `dp[i]` represents the number of ways to represent number `i` as a sum of powers of 2, where each power can be used at most twice.

2. **Transition**: For each power of 2 (1, 2, 4, 8, ...), we update our dp array:
   - `dp[i] += dp[i - power]` (use 1 of current power)
   - `dp[i] += dp[i - 2 * power]` (use 2 of current power)

3. **Base Case**: `dp[0] = 1` (one way to make 0: use nothing)

4. **Time Complexity**: O(n log n) where n is the target number
5. **Space Complexity**: O(n)

This approach efficiently counts all valid representations of the number as sums of powers of 2 with each power used at most twice.

