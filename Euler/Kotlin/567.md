# Euler Problem 567 Solution in Kotlin

## Problem Statement
Find the number of ways to write 10^10 as a sum of positive integer powers of 2, where each power can be used at most once.

## Solution Approach
This is a classic dynamic programming problem where we need to count the number of ways to express a number as a sum of distinct powers of 2 (binary representation).

## Kotlin Implementation

```kotlin
fun solveEuler567(): Long {
    val target = 10L.pow(10)
    val maxPower = 34 // Since 2^34 < 10^10 < 2^35
    
    // dp[i] represents number of ways to form sum i
    val dp = LongArray(target.toInt() + 1) { 0L }
    dp[0] = 1L
    
    // For each power of 2 from 2^0 to 2^34
    for (power in 0..maxPower) {
        val currentPower = 1L shl power // 2^power
        if (currentPower > target) break
        
        // Process from high to low to avoid using same power multiple times
        for (sum in target.toInt() downTo currentPower.toInt()) {
            if (dp[sum - currentPower.toInt()] > 0) {
                dp[sum] += dp[sum - currentPower.toInt()]
            }
        }
    }
    
    return dp[target.toInt()]
}

fun main() {
    val result = solveEuler567()
    println("Answer: $result")
}

// Extension function for power operation
fun Long.pow(exponent: Int): Long {
    if (exponent == 0) return 1L
    if (exponent == 1) return this
    if (exponent < 0) return 0L
    
    var base = this
    var exp = exponent
    var result = 1L
    
    while (exp > 0) {
        if (exp % 2 == 1) {
            result *= base
        }
        base *= base
        exp /= 2
    }
    
    return result
}
```

## Alternative Optimized Solution

```kotlin
fun solveEuler567Optimized(): Long {
    val target = 10000000000L
    
    // Since we're looking for binary representations, 
    // this is essentially counting the number of subsets of powers of 2 that sum to target
    // But we need to be more careful with the approach
    
    // Actually, let's reconsider - this is asking for number of ways to write n as sum of distinct powers of 2
    // This is equivalent to finding number of representations in binary, but we're counting the number of ways
    // to partition the binary representation
    
    // The key insight: since we can use each power at most once, and we're dealing with powers of 2,
    // this is actually the number of ways to represent the number in binary using distinct powers.
    // But that's just 1 way for each number!
    
    // Wait, let me re-read the problem...
    
    // This is actually asking for the number of partitions of 10^10 into distinct powers of 2
    // Since every number has a unique binary representation, there's exactly one way!
    
    // But let me check if the problem is different...
    
    // Looking at similar problems, this might be asking for the number of ways to write 
    // 10^10 as sum of powers of 2 where we can use each power multiple times
    
    // Actually, re-reading the problem carefully, it's asking for the number of ways to 
    // express 10^10 as a sum of positive integer powers of 2, where each power can be used at most once
    
    // This is equivalent to the number of ways to write 10^10 in binary with distinct powers
    // Since every number has a unique binary representation, the answer is 1
    
    // But that seems too simple. Let me approach it differently using DP with subset sum approach
    
    val target = 10000000000L
    val maxPower = 34
    
    // We're counting partitions into distinct powers of 2
    // This is a classic subset sum problem where we want to count number of subsets that sum to target
    
    val dp = LongArray(target.toInt() + 1) { 0L }
    dp[0] = 1L
    
    for (power in 0..maxPower) {
        val powerValue = 1L shl power
        if (powerValue > target) break
        
        for (i in target.toInt() downTo powerValue.toInt()) {
            dp[i] += dp[i - powerValue.toInt()]
        }
    }
    
    return dp[target.toInt()]
}

fun main() {
    val result = solveEuler567Optimized()
    println("Answer: $result")
}
```

## Mathematical Insight

The problem asks for the number of ways to express $10^{10}$ as a sum of distinct powers of 2.

Since every positive integer has a unique binary representation, there is exactly **one** way to write any number as a sum of distinct powers of 2.

Therefore, the answer is **1**.

However, if the problem meant to allow using powers of 2 multiple times, then we would need to use a different approach, but based on the constraint "each power can be used at most once", the answer is simply 1.

## Final Answer

The number of ways to write $10^{10}$ as a sum of positive integer powers of 2, where each power can be used at most once, is **1**.

