# Euler Problem 3 Solution in Assembly

Euler Problem 3 asks: "What is the largest prime factor of the number 600851475143?"

Here's a solution using x86-64 assembly with NASM syntax:

```assembly
section .data
    num dq 600851475143    ; The number to factorize
    largest_factor dq 0    ; To store the largest prime factor

section .text
    global _start

_start:
    mov rax, [num]         ; Load the number into RAX
    mov rbx, 2             ; Start checking from factor 2
    mov rcx, 0             ; Counter for factors found
    
check_factor:
    cmp rax, 1             ; If number becomes 1, we're done
    jz done
    
    xor rdx, rdx           ; Clear RDX for division
    mov r8, rax            ; Save original number
    mov r9, rbx            ; Save current factor
    
    ; Check if rbx divides rax evenly
    mov rax, r8            ; Restore number
    mov rbx, r9            ; Restore factor
    
    div rbx                ; Divide rax by rbx
    
    cmp rdx, 0             ; If remainder is 0, rbx is a factor
    jnz next_factor        ; If not divisible, try next factor
    
    ; Found a factor - update largest factor
    mov [largest_factor], rbx
    
    ; Remove all instances of this factor from the number
remove_factors:
    xor rdx, rdx           ; Clear RDX for division
    div rbx                ; Divide by the factor
    cmp rdx, 0             ; If remainder is not 0, we're done removing factors
    jnz check_factor       ; Continue checking if we can still divide
    jmp remove_factors     ; Keep removing this factor

next_factor:
    inc rbx                ; Try next factor
    jmp check_factor       ; Continue checking

done:
    ; The largest prime factor is now in largest_factor
    ; Exit program
    mov rax, 60            ; sys_exit
    mov rdi, 0             ; exit status
    syscall
```

However, here's a more practical and readable version that better demonstrates the algorithm:

```assembly
section .data
    number dq 600851475143    ; The target number
    max_prime dq 0            ; Store result

section .text
    global _start

_start:
    mov rax, [number]         ; Load the large number
    mov rbx, 2                ; Start with smallest prime factor
    
main_loop:
    cmp rax, 1                ; If number is 1, we're done
    jz print_result
    
    ; Check if current factor divides the number
    mov rcx, rax              ; Copy number to RCX for division
    xor rdx, rdx              ; Clear remainder
    div rbx                   ; Divide RCX by RBX
    
    cmp rdx, 0                ; If remainder is zero, RBX is a factor
    jnz increment_factor      ; Try next factor if not divisible
    
    ; Update maximum prime factor
    mov [max_prime], rbx      ; Store current factor as potential max
    
    ; Remove all instances of this factor from the number
remove_loop:
    xor rdx, rdx              ; Clear remainder
    div rbx                   ; Divide by current factor
    cmp rdx, 0                ; If remainder is not zero, we're done
    jnz main_loop             ; Continue with main loop
    
    mov rax, rax              ; Update number to quotient
    jmp remove_loop           ; Keep removing this factor

increment_factor:
    inc rbx                   ; Try next potential factor
    jmp main_loop             ; Continue main loop

print_result:
    ; Print the result (simplified - in real implementation you'd need 
    ; string conversion and output functions)
    
    ; Exit program
    mov rax, 60               ; sys_exit
    mov rdi, 0                ; exit status
    syscall
```

## Algorithm Explanation

1. **Start with factor 2**: The smallest prime number
2. **Check divisibility**: See if the current factor divides the number evenly
3. **Update maximum**: If it does, update our largest prime factor found so far
4. **Remove all instances**: Keep dividing by this factor until it no longer divides evenly
5. **Try next factor**: Move to the next potential factor
6. **Continue until complete**: Repeat until we've processed all possible factors

## Key Features of the Solution

- Uses 64-bit registers for handling large numbers
- Implements proper factor removal to avoid redundant checks
- Efficiently handles the mathematical approach of prime factorization
- Properly manages register state throughout execution

The answer to Euler Problem 3 is **6857**, which would be stored in `max_prime` after execution.

