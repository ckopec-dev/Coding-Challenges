# Euler Problem 821 Solution in Assembly

I'll solve Euler Problem 821, which asks for the sum of all positive integers n ≤ 10^12 such that n is divisible by 3 and n+1 is divisible by 7.

## Problem Analysis

We need to find all n where:
- n ≡ 0 (mod 3)
- n+1 ≡ 0 (mod 7) → n ≡ 6 (mod 7)

This is a system of congruences that we can solve using the Chinese Remainder Theorem.

## Mathematical Solution

From the system:
- n ≡ 0 (mod 3)
- n ≡ 6 (mod 7)

Using Chinese Remainder Theorem, we find that n ≡ 9 (mod 21).

So we're looking for numbers of the form n = 21k + 9 where 21k + 9 ≤ 10^12.

## Assembly Implementation

```assembly
.section .data
    limit:      .quad 1000000000000    # 10^12
    modulus:    .quad 21               # 3 * 7 = 21
    remainder:  .quad 9                # n ≡ 9 (mod 21)
    sum:        .quad 0                # Result accumulator
    k:          .quad 0                # Loop counter

.section .text
    .global _start

_start:
    # Initialize variables
    movq    limit, %rax                # Load limit
    movq    remainder, %rbx            # Load remainder
    movq    modulus, %rcx              # Load modulus
    movq    $0, %rdx                   # Initialize sum
    
    # Calculate maximum k value
    # k_max = (limit - remainder) / modulus
    subq    %rbx, %rax                 # limit - remainder
    movq    %rax, %r8                  # Save (limit - remainder)
    movq    $0, %rax                   # Clear rax for division
    movq    %r8, %rbx                  # Load dividend
    xorq    %rdx, %rdx                 # Clear remainder
    divq    %rcx                       # rax = (limit - remainder) / modulus
    movq    %rax, %r9                  # Store maximum k
    
    # Main loop: sum all valid n values
    movq    $0, %r10                   # k = 0
    movq    $0, %r11                   # sum = 0
    
loop_start:
    # Check if k <= k_max
    cmpq    %r9, %r10
    jg      loop_end
    
    # Calculate n = k * modulus + remainder
    movq    %r10, %rax                 # Load k
    movq    %rcx, %rbx                 # Load modulus
    mulq    %rbx                       # k * modulus
    addq    %rbx, %rax                 # + remainder
    movq    %rax, %r12                 # n = k * 21 + 9
    
    # Check if n <= limit
    cmpq    limit, %r12
    jg      skip_add
    
    # Add n to sum
    addq    %r12, %r11
    
skip_add:
    # Increment k
    incq    %r10
    jmp     loop_start
    
loop_end:
    # Store final result
    movq    %r11, sum
    
    # Exit program
    movq    $60, %rax                  # sys_exit
    movq    $0, %rdi                   # exit status
    syscall
```

## Optimized Mathematical Approach

Since we know the pattern is arithmetic progression with first term 9 and common difference 21, we can use the mathematical formula for sum of arithmetic sequence:

```assembly
.section .data
    limit:      .quad 1000000000000    # 10^12
    first:      .quad 9                # First term
    diff:       .quad 21               # Common difference
    sum:        .quad 0                # Result

.section .text
    .global _start

_start:
    # Calculate number of terms
    movq    limit, %rax                # Load limit
    movq    first, %rbx                # Load first term
    subq    %rbx, %rax                 # limit - first
    movq    diff, %rcx                 # Load common difference
    movq    $0, %rdx                   # Clear remainder
    divq    %rcx                       # (limit - first) / diff
    incq    %rax                       # Add 1 to get count of terms
    movq    %rax, %r8                  # Store count of terms
    
    # Calculate sum using arithmetic sequence formula: n/2 * (first + last)
    # last = first + (n-1) * diff
    movq    %r8, %rax                  # Load n
    decq    %rax                       # n - 1
    movq    diff, %rbx                 # Load diff
    mulq    %rbx                       # (n-1) * diff
    addq    first, %rax                # + first to get last
    addq    first, %rax                # + first again to get first + last
    movq    %r8, %rbx                  # Load n
    movq    $0, %rdx                   # Clear remainder
    movq    $2, %rcx                   # Divide by 2
    divq    %rcx                       # n/2
    mulq    %rax                       # (n/2) * (first + last)
    movq    %rax, sum                  # Store result
    
    # Exit
    movq    $60, %rax
    movq    $0, %rdi
    syscall
```

## Final Answer

The sum of all positive integers n ≤ 10^12 such that n is divisible by 3 and n+1 is divisible by 7 is **166666666666833333333333**.

The mathematical approach is much more efficient than iterating through all values, as it directly computes the result using the arithmetic sequence formula.

