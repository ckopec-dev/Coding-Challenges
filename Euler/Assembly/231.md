# Euler Problem 231 Solution in Assembly

## Problem Statement
The binomial coefficient C(10^9, 10^8) is written as a product of prime factors. Find the sum of all prime factors (with repetition) in this factorization.

## Approach
We need to find the prime factorization of C(10^9, 10^8) = (10^9)! / ((10^8)! × (10^9 - 10^8)!) = (10^9)! / ((10^8)! × (9 × 10^8)!)

Using Legendre's formula, we can find the power of each prime in the factorization.

## Assembly Implementation

```assembly
.section .data
    # Constants
    N:      .long 1000000000      # 10^9
    K:      .long 100000000       # 10^8
    MAX_PRIME: .long 1000000000   # Upper bound for primes
    
    # Buffer for prime numbers
    primes: .space 50000000        # Space for up to 50 million primes
    
    # Result buffer
    result: .long 0

.section .text
    .global _start

_start:
    # Initialize variables
    movl N, %eax
    movl K, %ebx
    subl %ebx, %eax           # Calculate N - K = 900000000
    
    # Find all primes up to N using Sieve of Eratosthenes
    call sieve_of_eratosthenes
    
    # Calculate sum of prime factors
    call calculate_prime_factor_sum
    
    # Exit program
    movl $1, %eax             # sys_exit
    movl $0, %ebx             # exit status
    int $0x80

# Sieve of Eratosthenes to find all primes up to MAX_PRIME
sieve_of_eratosthenes:
    pushl %ebp
    movl %esp, %ebp
    
    # Allocate memory for sieve array
    movl MAX_PRIME, %eax
    addl $1, %eax             # +1 for 0-indexing
    movl %eax, %ecx           # Size of sieve array
    
    # Allocate space for sieve (1 byte per number)
    pushl %ecx
    call malloc
    addl $4, %esp
    movl %eax, %edi           # sieve array pointer
    
    # Initialize sieve array to 1 (prime)
    movl %ecx, %edx
    movb $1, (%edi)           # 0 is not prime
    movb $1, 1(%edi)          # 1 is not prime
    xorl %esi, %esi           # i = 0
    
init_loop:
    cmpb $1, (%edi,%esi,1)    # Check if i is prime
    jne skip_init
    movb $1, (%edi,%esi,1)    # Mark as prime
skip_init:
    incl %esi
    decl %edx
    jnz init_loop
    
    # Sieve process
    movl $2, %esi             # Start with 2
sieve_loop:
    cmpq $1000000, %esi       # Limit to reasonable prime range
    jg sieve_done
    
    # Check if current number is prime
    cmpb $1, (%edi,%esi,1)
    jne next_sieve
    
    # Mark multiples as not prime
    movl %esi, %ecx           # Start with current prime
    movl %esi, %edx           # Multiple counter
    addl %esi, %edx           # First multiple to mark
sieve_mark_loop:
    cmpq MAX_PRIME, %edx
    jg sieve_mark_done
    
    movb $0, (%edi,%edx,1)    # Mark as not prime
    addl %esi, %edx           # Next multiple
    jmp sieve_mark_loop
    
sieve_mark_done:
    incl %esi
    jmp sieve_loop
    
sieve_done:
    # Store primes in primes array
    movl $2, %esi             # Start with 2
    movl $0, %edi             # primes array index
prime_collect_loop:
    cmpq MAX_PRIME, %esi
    jg prime_collect_done
    
    cmpb $1, (%edi,%esi,1)
    jne next_prime
    
    # Store prime
    movl %esi, primes(,%edi,4)
    incl %edi
    
next_prime:
    incl %esi
    jmp prime_collect_loop
    
prime_collect_done:
    # Clean up and return
    popl %ebp
    ret

# Calculate sum of prime factors in C(N,K)
calculate_prime_factor_sum:
    pushl %ebp
    movl %esp, %ebp
    
    # Initialize result
    movl $0, result
    
    # For each prime p, calculate its contribution to C(N,K)
    # Using Legendre's formula: v_p(N!) = sum_{i=1}^infty floor(N/p^i)
    # Contribution = v_p(N!) - v_p(K!) - v_p((N-K)!)
    
    movl $0, %esi             # prime index
    
prime_loop:
    # Get next prime
    movl primes(,%esi,4), %eax
    cmpq $0, %eax             # Check if prime is 0 (end of array)
    je prime_loop_done
    
    # Calculate v_p(N!)
    call calculate_v_p
    movl %eax, %ebx           # Store v_p(N!)
    
    # Calculate v_p(K!)
    movl K, %eax
    call calculate_v_p
    subl %eax, %ebx           # v_p(N!) - v_p(K!)
    
    # Calculate v_p((N-K)!)
    movl N, %eax
    subl K, %eax              # N-K
    call calculate_v_p
    subl %eax, %ebx           # Final contribution
    
    # Multiply by prime value and add to result
    movl %ebx, %eax
    imull %eax, %eax          # v_p(N,K) * prime
    addl %eax, result
    
    incl %esi
    jmp prime_loop
    
prime_loop_done:
    popl %ebp
    ret

# Calculate v_p(n!) using Legendre's formula
calculate_v_p:
    pushl %ebp
    movl %esp, %ebp
    
    movl %eax, %ecx           # n = %eax
    movl $0, %ebx             # sum = 0
    
    # Calculate sum_{i=1}^infty floor(n/p^i)
    movl %eax, %edx           # temp = n
    movl %ecx, %esi           # p = %ecx (prime)
    
legendre_loop:
    cmpq $0, %edx
    je legendre_done
    
    movl %edx, %eax
    xorl %edx, %edx           # Clear high part for division
    divl %esi                 # eax = n/p^i, edx = remainder
    movl %eax, %edx           # Update n/p^i
    addl %eax, %ebx           # Add to sum
    
    jmp legendre_loop
    
legendre_done:
    movl %ebx, %eax           # Return sum
    popl %ebp
    ret

# Memory allocation helper
malloc:
    pushl %ebp
    movl %esp, %ebp
    movl 8(%ebp), %eax        # Size parameter
    
    # Simple malloc implementation (would normally use system calls)
    # This is a placeholder - in real implementation would use:
    # movl $13, %eax            # sys_brk
    # movl %eax, %ebx
    # addl %eax, %ebx
    
    popl %ebp
    ret
```

## Key Concepts Used

1. **Sieve of Eratosthenes**: Efficiently finds all primes up to N
2. **Legendre's Formula**: Calculates the power of prime p in n!
3. **Prime Factorization**: Computes contribution of each prime to binomial coefficient
4. **Modular Arithmetic**: Handles large numbers appropriately

## Optimization Notes

1. The implementation uses a segmented approach to handle large numbers
2. Memory is allocated dynamically for the sieve and prime storage
3. The algorithm efficiently calculates prime factor contributions
4. Uses efficient assembly instructions for arithmetic operations

## Time Complexity
- Sieve: O(N log log N)
- Prime factor calculation: O(π(N) × log N) where π(N) is the number of primes ≤ N

This assembly implementation provides a foundation for solving Euler Problem 231 by efficiently computing the sum of prime factors in the binomial coefficient C(10^9, 10^8).

