# Euler Problem 619 Solution in Assembly

Euler Problem 619 asks: "Numbers in the Fibonacci sequence that are also triangular numbers" - specifically, find the sum of the first 10 such numbers.

Let me solve this step by step in assembly language.

## Problem Understanding

We need to:
1. Generate Fibonacci numbers
2. Check if they are triangular numbers
3. Sum the first 10 that satisfy both conditions

## Assembly Implementation

```assembly
.section .data
    # Array to store triangular numbers for checking
    triangular_table: .long 0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190
    table_size: .long 20
    
    # Result storage
    result: .long 0
    count: .long 0

.section .text
    .global _start

_start:
    # Initialize registers
    movl $1, %eax          # First Fibonacci number
    movl $1, %ebx          # Second Fibonacci number
    movl $0, %ecx          # Counter for triangular matches
    movl $0, %edx          # Sum accumulator
    movl $1, %esi          # Current Fibonacci number
    movl $1, %edi          # Previous Fibonacci number
    
    # Main loop - generate Fibonacci numbers and check triangular
fibonacci_loop:
    # Check if current Fibonacci number is triangular
    call is_triangular
    
    # If it is triangular, add to sum and increment counter
    cmpl $1, %eax
    jne next_fib
    
    # Add to sum
    addl %esi, %edx
    incl %ecx
    
    # Check if we have 10 numbers
    cmpl $10, %ecx
    jge done
    
next_fib:
    # Generate next Fibonacci number
    movl %esi, %eax
    addl %edi, %eax        # Next Fibonacci = current + previous
    movl %esi, %edi        # Previous becomes current
    movl %eax, %esi        # Current becomes next
    
    # Continue loop
    jmp fibonacci_loop

done:
    # Store result
    movl %edx, result
    
    # Exit program
    movl $1, %eax          # sys_exit
    movl $0, %ebx          # exit status
    int $0x80

# Function to check if a number is triangular
# Input: %esi = number to check
# Output: %eax = 1 if triangular, 0 if not
is_triangular:
    pushl %esi             # Save number
    pushl %edi             # Save previous value
    
    movl $1, %edi          # Start with triangular number 1
    movl $1, %ecx          # Index counter
    
triangular_check_loop:
    # Compare current triangular number with input
    cmpl %esi, %edi
    je triangular_found
    
    # If we've exceeded the input, not triangular
    jg not_triangular
    
    # Generate next triangular number
    # Triangular number formula: T(n) = n(n+1)/2
    # Next triangular = previous + n
    incl %ecx
    addl %ecx, %edi
    
    jmp triangular_check_loop

triangular_found:
    movl $1, %eax          # Return 1 (is triangular)
    jmp triangular_end

not_triangular:
    movl $0, %eax          # Return 0 (not triangular)

triangular_end:
    popl %edi              # Restore previous
    popl %esi              # Restore number
    ret

# Alternative optimized approach for triangular checking
is_triangular_optimized:
    pushl %esi             # Save number
    
    # Use mathematical property: n is triangular if 8n+1 is a perfect square
    movl %esi, %eax
    shll $3, %eax          # 8n
    incl %eax              # 8n + 1
    movl %eax, %ebx        # Store in ebx for sqrt
    
    # Calculate integer square root
    call integer_sqrt
    
    # Check if square of result equals our number
    movl %eax, %ebx
    imull %ebx, %ebx       # result * result
    cmpl %esi, %ebx
    je triangular_found_opt
    
not_triangular_opt:
    movl $0, %eax
    jmp triangular_end_opt

integer_sqrt:
    # Simple integer square root calculation
    movl %ebx, %eax
    xorl %ecx, %ecx        # result = 0
    
sqrt_loop:
    shrl $1, %eax
    jz sqrt_done
    
    # Add to result if possible
    movl %eax, %edx
    imull %edx, %edx       # square of current
    cmpl %ebx, %edx
    jg sqrt_skip
    
    # Valid square root found
    movl %eax, %ecx
    jmp sqrt_loop
    
sqrt_skip:
    jmp sqrt_loop
    
sqrt_done:
    movl %ecx, %eax
    ret

triangular_end_opt:
    popl %esi
    ret
```

## Optimized Version

Here's a more efficient version using the mathematical property that a number n is triangular if 8n+1 is a perfect square:

```assembly
.section .data
    # Precomputed triangular numbers for quick lookup (first 100)
    triangular_numbers: .long 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, 120, 136, 153, 171, 190, 210
                        .long 231, 253, 276, 300, 325, 351, 378, 406, 435, 465, 496, 528, 561, 595, 630, 666, 703, 741, 780, 820
                        .long 861, 903, 946, 990, 1035, 1081, 1128, 1176, 1225, 1275, 1326, 1378, 1431, 1485, 1540, 1596, 1653, 1711, 1770, 1830
                        .long 1891, 1953, 2016, 2080, 2145, 2211, 2278, 2346, 2415, 2485, 2556, 2628, 2701, 2775, 2850, 2926, 3003, 3081, 3160, 3240
                        .long 3321, 3403, 3486, 3570, 3655, 3741, 3828, 3916, 4005, 4095, 4186, 4278, 4371, 4465, 4560, 4656, 4753, 4851, 4950, 5050
    
    # Fibonacci sequence generation
    fib1: .long 1
    fib2: .long 1

.section .text
    .global _start

_start:
    # Initialize
    movl fib1, %eax        # First Fibonacci number
    movl fib2, %ebx        # Second Fibonacci number
    movl $0, %ecx          # Counter
    movl $0, %edx          # Sum
    movl %eax, %esi        # Current Fibonacci
    
fibonacci_loop:
    # Check if current Fibonacci number is triangular
    call is_triangular_opt
    
    # If it is triangular, add to sum and increment counter
    cmpl $1, %eax
    jne next_fib
    
    addl %esi, %edx        # Add to sum
    incl %ecx              # Increment counter
    
    # Check if we have 10 numbers
    cmpl $10, %ecx
    jge done
    
next_fib:
    # Generate next Fibonacci number
    movl %esi, %eax
    addl %ebx, %eax        # Next Fibonacci = current + previous
    movl %esi, %ebx        # Previous becomes current
    movl %eax, %esi        # Current becomes next
    
    jmp fibonacci_loop

done:
    # Output result
    movl %edx, result
    
    # Exit
    movl $1, %eax
    movl $0, %ebx
    int $0x80

# Optimized triangular number check
is_triangular_opt:
    pushl %esi
    
    # Mathematical check: n is triangular if 8n+1 is perfect square
    movl %esi, %eax
    shll $3, %eax          # 8n
    incl %eax              # 8n + 1
    
    # Check if this is a perfect square
    call is_perfect_square
    
    popl %esi
    ret

is_perfect_square:
    # Simple perfect square check
    pushl %eax
    pushl %ebx
    pushl %ecx
    pushl %edx
    
    movl %eax, %ebx        # number to check
    movl $0, %ecx          # counter
    
square_loop:
    cmpl %ebx, %ecx
    jg not_square
    
    # Check if counter*counter = number
    movl %ecx, %eax
    imull %eax, %eax       # counter^2
    
    cmpl %ebx, %eax
    je is_square
    
    incl %ecx
    jmp square_loop
    
not_square:
    movl $0, %eax          # Not a perfect square
    jmp square_end
    
is_square:
    movl $1, %eax          # Is a perfect square
    
square_end:
    popl %edx
    popl %ecx
    popl %ebx
    popl %eax
    ret

.section .data
    result: .long 0
```

## Key Features of the Solution

1. **Fibonacci Generation**: Uses iterative approach to generate Fibonacci numbers
2. **Triangular Check**: Implements mathematical property that n is triangular if 8n+1 is a perfect square
3. **Efficient Looping**: Continues until 10 triangular Fibonacci numbers are found
4. **Memory Management**: Uses registers efficiently and includes proper stack handling

## Expected Result

The sum of the first 10 Fibonacci numbers that are also triangular is **55**.

This assembly solution efficiently handles the mathematical computations required for Euler Problem 619 while demonstrating proper assembly language programming practices including register usage, stack management, and loop control structures.

