# Euler Problem 484 Solution in Pascal

## Problem Statement
Find the sum of all numbers n ≤ 10^11 such that the number of divisors of n is exactly 24.

## Solution Approach
We need to find all numbers n ≤ 10^11 where d(n) = 24, where d(n) is the number of divisors of n.

The number of divisors function d(n) for a number n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ is:
d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1)

For d(n) = 24, we need to find all possible factorizations of 24:
24 = 24 × 1
24 = 12 × 2
24 = 8 × 3
24 = 6 × 4
24 = 6 × 2 × 2
24 = 4 × 3 × 2
24 = 3 × 2 × 2 × 2

This corresponds to the possible forms of n:
1. p²³
2. p¹¹ × q¹
3. p⁷ × q¹
4. p⁵ × q¹
5. p⁵ × q¹ × r¹
6. p³ × q¹ × r¹
7. p¹ × q¹ × r¹ × s¹

## Pascal Implementation

```pascal
program Euler484;
{$APPTYPE CONSOLE}

uses
  SysUtils, Math;

const
  LIMIT = 100000000000; // 10^11
  MAX_PRIMES = 1000000;
  
var
  primes: array[1..MAX_PRIMES] of Int64;
  primeCount: Integer;
  result: Int64;

function IsPrime(n: Int64): Boolean;
var
  i: Integer;
begin
  if n < 2 then
  begin
    IsPrime := False;
    Exit;
  end;
  
  if n = 2 then
  begin
    IsPrime := True;
    Exit;
  end;
  
  if n mod 2 = 0 then
  begin
    IsPrime := False;
    Exit;
  end;
  
  for i := 3 to Trunc(Sqrt(n)) do
  begin
    if n mod i = 0 then
    begin
      IsPrime := False;
      Exit;
    end;
  end;
  
  IsPrime := True;
end;

procedure SieveOfEratosthenes(maxNum: Int64);
var
  i, j: Int64;
  isPrime: array[1..100000000] of Boolean;
begin
  FillChar(isPrime, SizeOf(isPrime), True);
  isPrime[1] := False;
  
  for i := 2 to Trunc(Sqrt(maxNum)) do
  begin
    if isPrime[i] then
    begin
      for j := i * i to maxNum do
      begin
        if j mod i = 0 then
          isPrime[j] := False;
      end;
    end;
  end;
  
  primeCount := 0;
  for i := 2 to maxNum do
  begin
    if isPrime[i] then
    begin
      Inc(primeCount);
      primes[primeCount] := i;
    end;
  end;
end;

function Power(base, exp: Int64): Int64;
begin
  Power := Int64(Power(Real(base), exp));
end;

function CountDivisors(n: Int64): Integer;
var
  i, count: Integer;
  temp: Int64;
begin
  count := 0;
  temp := n;
  
  for i := 1 to primeCount do
  begin
    if primes[i] * primes[i] > temp then
      Break;
      
    if temp mod primes[i] = 0 then
    begin
      Inc(count);
      while temp mod primes[i] = 0 do
      begin
        temp := temp div primes[i];
      end;
    end;
  end;
  
  if temp > 1 then
    Inc(count);
    
  CountDivisors := Power(2, count);
end;

function GenerateNumbers(): Int64;
var
  i, j, k, l: Integer;
  n: Int64;
  sum: Int64;
begin
  sum := 0;
  
  // Form 1: p^23
  for i := 1 to primeCount do
  begin
    n := Power(primes[i], 23);
    if n > LIMIT then
      Break;
    sum := sum + n;
  end;
  
  // Form 2: p^11 * q^1
  for i := 1 to primeCount do
  begin
    if Power(primes[i], 11) > LIMIT then
      Break;
      
    for j := i + 1 to primeCount do
    begin
      n := Power(primes[i], 11) * primes[j];
      if n > LIMIT then
        Break;
      sum := sum + n;
    end;
  end;
  
  // Form 3: p^7 * q^1
  for i := 1 to primeCount do
  begin
    if Power(primes[i], 7) > LIMIT then
      Break;
      
    for j := i + 1 to primeCount do
    begin
      n := Power(primes[i], 7) * primes[j];
      if n > LIMIT then
        Break;
      sum := sum + n;
    end;
  end;
  
  // Form 4: p^5 * q^1
  for i := 1 to primeCount do
  begin
    if Power(primes[i], 5) > LIMIT then
      Break;
      
    for j := i + 1 to primeCount do
    begin
      n := Power(primes[i], 5) * primes[j];
      if n > LIMIT then
        Break;
      sum := sum + n;
    end;
  end;
  
  // Form 5: p^5 * q^1 * r^1
  for i := 1 to primeCount do
  begin
    if Power(primes[i], 5) > LIMIT then
      Break;
      
    for j := i + 1 to primeCount do
    begin
      if Power(primes[i], 5) * primes[j] > LIMIT then
        Break;
        
      for k := j + 1 to primeCount do
      begin
        n := Power(primes[i], 5) * primes[j] * primes[k];
        if n > LIMIT then
          Break;
        sum := sum + n;
      end;
    end;
  end;
  
  // Form 6: p^3 * q^1 * r^1
  for i := 1 to primeCount do
  begin
    if Power(primes[i], 3) > LIMIT then
      Break;
      
    for j := i + 1 to primeCount do
    begin
      if Power(primes[i], 3) * primes[j] > LIMIT then
        Break;
        
      for k := j + 1 to primeCount do
      begin
        n := Power(primes[i], 3) * primes[j] * primes[k];
        if n > LIMIT then
          Break;
        sum := sum + n;
      end;
    end;
  end;
  
  // Form 7: p^1 * q^1 * r^1 * s^1
  for i := 1 to primeCount do
  begin
    if primes[i] > LIMIT then
      Break;
      
    for j := i + 1 to primeCount do
    begin
      if primes[i] * primes[j] > LIMIT then
        Break;
        
      for k := j + 1 to primeCount do
      begin
        if primes[i] * primes[j] * primes[k] > LIMIT then
          Break;
          
        for l := k + 1 to primeCount do
        begin
          n := primes[i] * primes[j] * primes[k] * primes[l];
          if n > LIMIT then
            Break;
          sum := sum + n;
        end;
      end;
    end;
  end;
  
  GenerateNumbers := sum;
end;

begin
  SieveOfEratosthenes(1000000);
  result := GenerateNumbers();
  Writeln('Result: ', result);
  Readln;
end.
```

## Key Points of the Solution

1. **Prime Generation**: Uses Sieve of Eratosthenes to generate primes up to 1,000,000
2. **Number Forms**: Enumerates all possible forms of numbers with exactly 24 divisors
3. **Efficiency**: Early termination when numbers exceed the limit
4. **Memory Management**: Uses efficient prime storage and avoids unnecessary calculations

## Note
This is a simplified implementation. The actual implementation would require more sophisticated optimizations and handling of edge cases for such a large search space. The algorithm systematically generates all possible combinations of prime powers that satisfy the divisor condition and sums those that are ≤ 10^11.

The result should be a large integer representing the sum of all qualifying numbers.

