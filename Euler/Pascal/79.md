# Euler Problem 79 Solution in Pascal

## Problem Statement
A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was 531278, they may ask for the 2nd, 3rd, and 5th characters; the expected reply would be: 317.

The text file, `keylog.txt`, contains fifty successful login attempts.

Given that the three characters are always asked for in order, analyse the file to determine the shortest possible secret passcode of unknown length.

## Solution Approach
We need to find the shortest passcode that satisfies all the given 3-character sequences. This is essentially a topological sorting problem where we need to determine the order of digits based on their appearance in the sequences.

## Pascal Implementation

```pascal
program Euler79;

{$APPTYPE CONSOLE}

uses
  SysUtils, Classes;

type
  TCharSet = set of char;
  TGraph = array['0'..'9'] of TCharSet;
  TVisited = array['0'..'9'] of boolean;

var
  graph: TGraph;
  visited: TVisited;
  stack: array[1..10] of char;
  stackTop: integer;
  sequences: TStringList;

procedure InitializeGraph;
var
  i: integer;
begin
  for i := ord('0') to ord('9') do
    graph[char(i)] := [];
  stackTop := 0;
  for i := ord('0') to ord('9') do
    visited[char(i)] := false;
end;

procedure AddEdge(from, to: char);
begin
  graph[from] := graph[from] + [to];
end;

procedure TopologicalSort(vertex: char; var result: string);
var
  neighbor: char;
begin
  visited[vertex] := true;
  for neighbor := '0' to '9' do
  begin
    if (neighbor in graph[vertex]) and not visited[neighbor] then
      TopologicalSort(neighbor, result);
  end;
  result := vertex + result;
end;

function FindShortestPasscode: string;
var
  result: string;
  i: integer;
begin
  result := '';
  for i := ord('0') to ord('9') do
  begin
    if not visited[char(i)] then
      TopologicalSort(char(i), result);
  end;
  FindShortestPasscode := result;
end;

procedure ProcessSequences;
var
  i, j: integer;
  sequence: string;
begin
  InitializeGraph;
  
  // Read all sequences from file
  sequences := TStringList.Create;
  try
    sequences.LoadFromFile('keylog.txt');
    
    // Process each sequence
    for i := 0 to sequences.Count - 1 do
    begin
      sequence := Trim(sequences[i]);
      if Length(sequence) = 3 then
      begin
        // Add edges: first -> second, second -> third
        AddEdge(sequence[1], sequence[2]);
        AddEdge(sequence[2], sequence[3]);
      end;
    end;
  finally
    sequences.Free;
  end;
end;

function GetPasscodeFromGraph: string;
var
  i: integer;
  result: string;
begin
  result := '';
  for i := ord('0') to ord('9') do
    visited[char(i)] := false;
  
  for i := ord('0') to ord('9') do
  begin
    if not visited[char(i)] then
      TopologicalSort(char(i), result);
  end;
  
  GetPasscodeFromGraph := result;
end;

begin
  ProcessSequences;
  Writeln('Shortest possible passcode: ', GetPasscodeFromGraph);
end.
```

## Alternative Simpler Approach

Since we know the problem involves finding the order of digits based on their positions in sequences, here's a more direct approach:

```pascal
program Euler79_Simple;

{$APPTYPE CONSOLE}

uses
  SysUtils, Classes;

var
  sequences: TStringList;
  order: array['0'..'9'] of integer;
  used: array['0'..'9'] of boolean;
  passcode: string;

procedure ReadSequences;
begin
  sequences := TStringList.Create;
  try
    sequences.LoadFromFile('keylog.txt');
  except
    on E: Exception do
    begin
      Writeln('Error reading file: ', E.Message);
      Halt;
    end;
  end;
end;

procedure AnalyzeSequences;
var
  i, j: integer;
  sequence: string;
  first, second, third: char;
begin
  // Initialize
  for i := ord('0') to ord('9') do
  begin
    order[char(i)] := 0;
    used[char(i)] := false;
  end;
  
  // Process each sequence to determine relative positions
  for i := 0 to sequences.Count - 1 do
  begin
    sequence := Trim(sequences[i]);
    if Length(sequence) = 3 then
    begin
      first := sequence[1];
      second := sequence[2];
      third := sequence[3];
      
      // Update order based on sequence
      if not used[first] then
      begin
        order[first] := 1;
        used[first] := true;
      end;
      
      if not used[second] then
      begin
        order[second] := 2;
        used[second] := true;
      end;
      
      if not used[third] then
      begin
        order[third] := 3;
        used[third] := true;
      end;
    end;
  end;
end;

function FindPasscode: string;
var
  i, j: integer;
  tempOrder: array['0'..'9'] of integer;
  tempUsed: array['0'..'9'] of boolean;
  result: string;
begin
  // Copy arrays for sorting
  for i := ord('0') to ord('9') do
  begin
    tempOrder[i] := order[char(i)];
    tempUsed[i] := used[char(i)];
  end;
  
  result := '';
  // Sort by order value
  for i := 1 to 9 do
  begin
    for j := ord('0') to ord('9') do
    begin
      if tempUsed[j] and (tempOrder[j] = i) then
      begin
        result := result + char(j);
        tempUsed[j] := false;
        break;
      end;
    end;
  end;
  
  FindPasscode := result;
end;

begin
  ReadSequences;
  AnalyzeSequences;
  Writeln('Shortest possible passcode: ', FindPasscode);
  sequences.Free;
end.
```

## Correct Approach Using Topological Sort

The most accurate solution using proper topological sorting:

```pascal
program Euler79_Correct;

{$APPTYPE CONSOLE}

uses
  SysUtils, Classes;

type
  TCharSet = set of char;
  TGraph = array['0'..'9'] of TCharSet;

var
  graph: TGraph;
  inDegree: array['0'..'9'] of integer;
  sequences: TStringList;

procedure InitializeGraph;
var
  i: integer;
begin
  for i := ord('0') to ord('9') do
  begin
    graph[char(i)] := [];
    inDegree[char(i)] := 0;
  end;
end;

procedure AddEdge(from, to: char);
begin
  if not (to in graph[from]) then
  begin
    graph[from] := graph[from] + [to];
    inDegree[to] := inDegree[to] + 1;
  end;
end;

function FindTopologicalOrder: string;
var
  queue: array[1..10] of char;
  head, tail: integer;
  current: char;
  result: string;
  i: integer;
begin
  head := 1;
  tail := 0;
  
  // Initialize queue with nodes having in-degree 0
  for i := ord('0') to ord('9') do
  begin
    if inDegree[char(i)] = 0 then
    begin
      tail := tail + 1;
      queue[tail] := char(i);
    end;
  end;
  
  result := '';
  while head <= tail do
  begin
    current := queue[head];
    head := head + 1;
    result := result + current;
    
    // Remove edges from current node
    for i := ord('0') to ord('9') do
    begin
      if i in graph[current] then
      begin
        inDegree[char(i)] := inDegree[char(i)] - 1;
        if inDegree[char(i)] = 0 then
        begin
          tail := tail + 1;
          queue[tail] := char(i);
        end;
      end;
    end;
  end;
  
  FindTopologicalOrder := result;
end;

procedure ProcessFile;
var
  i: integer;
  sequence: string;
begin
  InitializeGraph;
  
  for i := 0 to sequences.Count - 1 do
  begin
    sequence := Trim(sequences[i]);
    if Length(sequence) = 3 then
    begin
      AddEdge(sequence[1], sequence[2]);
      AddEdge(sequence[2], sequence[3]);
    end;
  end;
end;

begin
  sequences := TStringList.Create;
  try
    sequences.LoadFromFile('keylog.txt');
    ProcessFile;
    Writeln('Shortest possible passcode: ', FindTopologicalOrder);
  except
    on E: Exception do
      Writeln('Error: ', E.Message);
  end;
  sequences.Free;
end.
```

## Expected Output
The solution should output the shortest passcode that satisfies all the given sequences in the keylog.txt file.

**Note**: This requires a `keylog.txt` file containing the 50 login attempts. The actual passcode will depend on the specific sequences in that file.

