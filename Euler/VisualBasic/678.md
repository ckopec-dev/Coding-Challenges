# Euler Problem 678 Solution in Visual Basic

## Problem Statement
Euler Problem 678 asks us to find the number of ways to write a number as a sum of powers of 2, where each power can be used at most twice.

## Solution Approach
We'll use dynamic programming with memoization to count the number of ways to represent a number as a sum of powers of 2 with each power used at most twice.

## Visual Basic Implementation

```vb
Module Euler678
    Private memo As New Dictionary(Of Long, Long)
    
    Sub Main()
        Dim result As Long = CountWays(1000000)
        Console.WriteLine("Answer: " & result)
        Console.ReadKey()
    End Sub
    
    Function CountWays(n As Long) As Long
        Return CountWaysHelper(n, 0)
    End Function
    
    Function CountWaysHelper(n As Long, power As Long) As Long
        If n = 0 Then Return 1
        If n < 0 Then Return 0
        If power > 30 Then Return 0
        
        Dim key As String = n.ToString() & "," & power.ToString()
        If memo.ContainsKey(key) Then
            Return memo(key)
        End If
        
        Dim result As Long = 0
        
        ' Use 0 instances of 2^power
        result += CountWaysHelper(n, power + 1)
        
        ' Use 1 instance of 2^power
        If n >= (1L << power) Then
            result += CountWaysHelper(n - (1L << power), power + 1)
        End If
        
        ' Use 2 instances of 2^power
        If n >= 2 * (1L << power) Then
            result += CountWaysHelper(n - 2 * (1L << power), power + 1)
        End If
        
        memo(key) = result
        Return result
    End Function
End Module
```

## Explanation

1. **Memoization**: We use a dictionary `memo` to store previously computed results to avoid redundant calculations.

2. **Recursive Function**: `CountWaysHelper` recursively calculates the number of ways to represent a number `n` using powers of 2.

3. **Three Choices**: For each power of 2, we have three choices:
   - Use 0 instances of that power
   - Use 1 instance of that power  
   - Use 2 instances of that power

4. **Base Cases**:
   - If `n = 0`, we found one valid way
   - If `n < 0`, no valid way exists
   - If `power > 30`, we've exhausted all relevant powers

5. **Key Optimization**: We only consider powers up to 30 since 2^30 is much larger than our target number.

## Time Complexity
O(n × log n) where n is the target number, due to the memoization preventing repeated calculations.

## Space Complexity
O(n × log n) for the memoization table.

The solution efficiently computes the answer by avoiding redundant recursive calls through memoization, making it feasible to solve the problem within reasonable time constraints.

