# Euler Problem 862 Solution in Visual Basic

I'll solve Euler Problem 862, which asks for the number of ways to write a number as a sum of powers of 2, where each power can be used at most twice.

```vb
Module Euler862
    Sub Main()
        Dim result As Long = SolveProblem()
        Console.WriteLine("Answer: " & result)
        Console.ReadKey()
    End Sub
    
    Function SolveProblem() As Long
        Dim n As Long = 1000000
        Dim MOD As Long = 1000000007
        
        ' dp[i] represents number of ways to write i as sum of powers of 2
        ' where each power can be used at most twice
        Dim dp(1000000) As Long
        
        ' Base case
        dp(0) = 1
        
        ' For each power of 2
        Dim power As Long = 1
        While power <= n
            ' For each number from power to n
            For i As Long = power To n
                ' We can use this power 0, 1, or 2 times
                ' dp[i] += dp[i - power] (use 1 power)
                ' But we need to be careful about the constraint
                ' Since we can use each power at most twice, we need to be more careful
                
                ' Actually, let's think differently:
                ' We process powers in order, and for each power we can use it 0, 1, or 2 times
                ' So for each power p, we update dp[i] += dp[i-p] + dp[i-2*p] (if valid)
                ' But we need to be careful with the order of processing
                
                ' Better approach: process in reverse order for each power
                ' This ensures we don't double count
                
                ' For power p, we can use 0, 1, or 2 copies
                ' So for each i >= 2*p: dp[i] += dp[i-2*p]
                ' For each i >= p: dp[i] += dp[i-p]
                
                ' Process in reverse order to avoid overcounting
                If i >= 2 * power Then
                    dp(i) = (dp(i) + dp(i - 2 * power)) Mod MOD
                End If
                If i >= power Then
                    dp(i) = (dp(i) + dp(i - power)) Mod MOD
                End If
            Next
            power *= 2
        End While
        
        Return dp(n)
    End Function
    
    ' Alternative cleaner approach
    Function SolveProblemClean() As Long
        Dim n As Long = 1000000
        Dim MOD As Long = 1000000007
        
        ' dp[i] = number of ways to write i as sum of powers of 2 with each power used at most twice
        Dim dp(1000000) As Long
        dp(0) = 1
        
        Dim power As Long = 1
        While power <= n
            ' Process in reverse order to avoid double counting
            For i As Long = n To power Step -1
                ' We can use this power 0, 1, or 2 times
                ' But since we're processing in reverse, we can simply add:
                ' dp[i] += dp[i - power] + dp[i - 2 * power] if both are valid
                If i >= power Then
                    dp(i) = (dp(i) + dp(i - power)) Mod MOD
                End If
                If i >= 2 * power Then
                    dp(i) = (dp(i) + dp(i - 2 * power)) Mod MOD
                End If
            Next
            power *= 2
        End While
        
        Return dp(n)
    End Function
    
    ' Even cleaner version
    Function SolveProblemFinal() As Long
        Dim n As Long = 1000000
        Dim MOD As Long = 1000000007
        
        Dim dp(1000000) As Long
        dp(0) = 1
        
        Dim power As Long = 1
        While power <= n
            For i As Long = n To power Step -1
                If i >= power Then
                    dp(i) = (dp(i) + dp(i - power)) Mod MOD
                End If
                If i >= 2 * power Then
                    dp(i) = (dp(i) + dp(i - 2 * power)) Mod MOD
                End If
            Next
            power *= 2
        End While
        
        Return dp(n)
    End Function
End Module
```

The solution works by using dynamic programming where:

1. We maintain a `dp` array where `dp[i]` represents the number of ways to express the number `i` as a sum of powers of 2
2. For each power of 2 (1, 2, 4, 8, 16, ...), we process all numbers from `n` down to that power
3. For each number `i`, we can either:
   - Not use the current power (no change)
   - Use it once: add `dp[i - power]`
   - Use it twice: add `dp[i - 2 * power]`
4. We process in reverse order to avoid counting the same way multiple times
5. The answer is `dp[1000000]` modulo 1000000007

This approach efficiently computes the result in O(n log n) time complexity.

