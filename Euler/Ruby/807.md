# Euler Problem 807 Solution in Ruby

Let me solve this step by step.

First, I need to understand what Euler Problem 807 is asking for. Looking at the problem statement:

We need to find the sum of all positive integers n ≤ 10^12 such that n has exactly 12 divisors.

Let me analyze what numbers have exactly 12 divisors.

The number of divisors function d(n) can be determined from the prime factorization of n. If n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, then d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1).

For d(n) = 12, we need to find all ways to write 12 as a product of integers ≥ 2:
- 12 = 12 (so n = p₁¹¹)
- 12 = 6 × 2 (so n = p₁⁵ × p₂¹)
- 12 = 4 × 3 (so n = p₁³ × p₂²)
- 12 = 3 × 2 × 2 (so n = p₁² × p₂¹ × p₃¹)
- 12 = 2 × 2 × 3 (so n = p₁¹ × p₂¹ × p₃²)
- 12 = 2 × 6 (so n = p₁¹ × p₂⁵)
- 12 = 2 × 2 × 2 × 3 (so n = p₁¹ × p₂¹ × p₃¹ × p₄¹)

Wait, let me reconsider the factorizations more carefully:
- 12 = 12 (n = p₁¹¹)
- 12 = 6 × 2 (n = p₁⁵ × p₂¹) 
- 12 = 4 × 3 (n = p₁³ × p₂²)
- 12 = 3 × 2 × 2 (n = p₁² × p₂¹ × p₃¹)
- 12 = 2 × 2 × 3 (n = p₁¹ × p₂¹ × p₃²)
- 12 = 2 × 6 (n = p₁¹ × p₂⁵)
- 12 = 2 × 2 × 2 × 3 (n = p₁¹ × p₂¹ × p₃¹ × p₄¹)

Actually, the valid combinations are:
1. n = p₁¹¹ (12 divisors)
2. n = p₁⁵ × p₂¹ (12 divisors)  
3. n = p₁³ × p₂² (12 divisors)
4. n = p₁² × p₂¹ × p₃¹ (12 divisors)
5. n = p₁¹ × p₂¹ × p₃² (12 divisors)
6. n = p₁¹ × p₂⁵ (12 divisors)
7. n = p₁¹ × p₂¹ × p₃¹ × p₄¹ (12 divisors)

Now I'll implement the solution:

```ruby
require 'prime'

def count_divisors(n)
  return 1 if n == 1
  divisors = 1
  Prime.each(n) do |p|
    break if p * p > n
    if n % p == 0
      count = 0
      while n % p == 0
        n /= p
        count += 1
      end
      divisors *= (count + 1)
    end
  end
  divisors *= 2 if n > 1
  divisors
end

def solve(limit)
  result = 0
  
  # Case 1: n = p^11
  p = 2
  while p**11 <= limit
    result += p**11
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 2: n = p^5 * q
  p = 2
  while p**5 <= limit
    q = Prime.fetch(Prime.index(p) + 1)
    while q <= limit / p**5
      result += p**5 * q
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 3: n = p^3 * q^2
  p = 2
  while p**3 <= limit
    q = Prime.fetch(Prime.index(p) + 1)
    while q**2 <= limit / p**3
      result += p**3 * q**2
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 4: n = p^2 * q * r
  p = 2
  while p**2 <= limit
    q = Prime.fetch(Prime.index(p) + 1)
    while q <= limit / p**2
      r = Prime.fetch(Prime.index(q) + 1)
      while r <= limit / (p**2 * q)
        result += p**2 * q * r
        r = Prime.fetch(Prime.index(r) + 1)
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 5: n = p * q * r^2
  p = 2
  while p <= limit
    q = Prime.fetch(Prime.index(p) + 1)
    while q <= limit / p
      r = Prime.fetch(Prime.index(q) + 1)
      while r**2 <= limit / (p * q)
        result += p * q * r**2
        r = Prime.fetch(Prime.index(r) + 1)
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 6: n = p * q^5
  p = 2
  while p <= limit
    q = Prime.fetch(Prime.index(p) + 1)
    while q**5 <= limit / p
      result += p * q**5
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 7: n = p * q * r * s
  p = 2
  while p <= limit
    q = Prime.fetch(Prime.index(p) + 1)
    while q <= limit / p
      r = Prime.fetch(Prime.index(q) + 1)
      while r <= limit / (p * q)
        s = Prime.fetch(Prime.index(r) + 1)
        while s <= limit / (p * q * r)
          result += p * q * r * s
          s = Prime.fetch(Prime.index(s) + 1)
        end
        r = Prime.fetch(Prime.index(r) + 1)
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  result
end

# Let's use a more efficient approach
def efficient_solve(limit)
  primes = []
  prime = 2
  while prime * prime <= limit
    primes << prime
    prime = Prime.fetch(Prime.index(prime) + 1)
  end
  
  # We'll generate all valid numbers and check them
  result = 0
  
  # Case 1: p^11
  p = 2
  while p**11 <= limit
    result += p**11
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 2: p^5 * q
  p = 2
  while p**5 <= limit
    q = 2
    while q <= limit / p**5
      if Prime.prime?(q)
        result += p**5 * q
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 3: p^3 * q^2
  p = 2
  while p**3 <= limit
    q = 2
    while q**2 <= limit / p**3
      if Prime.prime?(q)
        result += p**3 * q**2
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 4: p^2 * q * r
  p = 2
  while p**2 <= limit
    q = 2
    while q <= limit / p**2
      if Prime.prime?(q)
        r = 2
        while r <= limit / (p**2 * q)
          if Prime.prime?(r)
            result += p**2 * q * r
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 5: p * q * r^2
  p = 2
  while p <= limit
    q = 2
    while q <= limit / p
      if Prime.prime?(q)
        r = 2
        while r**2 <= limit / (p * q)
          if Prime.prime?(r)
            result += p * q * r**2
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 6: p * q^5
  p = 2
  while p <= limit
    q = 2
    while q**5 <= limit / p
      if Prime.prime?(q)
        result += p * q**5
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 7: p * q * r * s
  p = 2
  while p <= limit
    q = 2
    while q <= limit / p
      if Prime.prime?(q)
        r = 2
        while r <= limit / (p * q)
          if Prime.prime?(r)
            s = 2
            while s <= limit / (p * q * r)
              if Prime.prime?(s)
                result += p * q * r * s
              end
              s = Prime.fetch(Prime.index(s) + 1)
            end
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  result
end

# Actually, let me think of a cleaner approach:
def solve_euler_807(limit)
  # Precompute primes up to sqrt(limit) for efficiency
  primes = []
  p = 2
  while p * p <= limit
    primes << p
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  result = 0
  
  # Generate all numbers with exactly 12 divisors
  # Method: For each valid divisor pattern, generate all valid combinations
  
  # Pattern 1: p^11
  p = 2
  while p**11 <= limit
    result += p**11
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Pattern 2: p^5 * q
  p = 2
  while p**5 <= limit
    q = 2
    while q <= limit / p**5
      if Prime.prime?(q)
        result += p**5 * q
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Pattern 3: p^3 * q^2
  p = 2
  while p**3 <= limit
    q = 2
    while q**2 <= limit / p**3
      if Prime.prime?(q)
        result += p**3 * q**2
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Pattern 4: p^2 * q * r
  p = 2
  while p**2 <= limit
    q = 2
    while q <= limit / p**2
      if Prime.prime?(q)
        r = 2
        while r <= limit / (p**2 * q)
          if Prime.prime?(r)
            result += p**2 * q * r
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Pattern 5: p * q * r^2
  p = 2
  while p <= limit
    q = 2
    while q <= limit / p
      if Prime.prime?(q)
        r = 2
        while r**2 <= limit / (p * q)
          if Prime.prime?(r)
            result += p * q * r**2
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Pattern 6: p * q^5
  p = 2
  while p <= limit
    q = 2
    while q**5 <= limit / p
      if Prime.prime?(q)
        result += p * q**5
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Pattern 7: p * q * r * s
  p = 2
  while p <= limit
    q = 2
    while q <= limit / p
      if Prime.prime?(q)
        r = 2
        while r <= limit / (p * q)
          if Prime.prime?(r)
            s = 2
            while s <= limit / (p * q * r)
              if Prime.prime?(s)
                result += p * q * r * s
              end
              s = Prime.fetch(Prime.index(s) + 1)
            end
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  result
end

# Let's compute the final answer
puts solve_euler_807(10**12)
```

Actually, let me write a cleaner and more efficient solution:

```ruby
require 'prime'

def count_divisors(n)
  divisors = 1
  Prime.each(n) do |p|
    break if p * p > n
    if n % p == 0
      count = 0
      while n % p == 0
        n /= p
        count += 1
      end
      divisors *= (count + 1)
    end
  end
  divisors *= 2 if n > 1
  divisors
end

def solve(limit)
  result = 0
  
  # Generate all valid combinations that produce exactly 12 divisors
  # We'll use the fact that for 12 divisors, we have these forms:
  # 1. p^11
  # 2. p^5 * q  
  # 3. p^3 * q^2
  # 4. p^2 * q * r
  # 5. p * q * r^2
  # 6. p * q^5
  # 7. p * q * r * s
  
  # Precompute primes
  primes = []
  p = 2
  while p * p <= limit
    primes << p
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 1: p^11
  p = 2
  while p**11 <= limit
    result += p**11
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 2: p^5 * q
  p = 2
  while p**5 <= limit
    q = 2
    while q <= limit / p**5
      if Prime.prime?(q)
        result += p**5 * q
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 3: p^3 * q^2
  p = 2
  while p**3 <= limit
    q = 2
    while q**2 <= limit / p**3
      if Prime.prime?(q)
        result += p**3 * q**2
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 4: p^2 * q * r
  p = 2
  while p**2 <= limit
    q = 2
    while q <= limit / p**2
      if Prime.prime?(q)
        r = 2
        while r <= limit / (p**2 * q)
          if Prime.prime?(r)
            result += p**2 * q * r
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 5: p * q * r^2
  p = 2
  while p <= limit
    q = 2
    while q <= limit / p
      if Prime.prime?(q)
        r = 2
        while r**2 <= limit / (p * q)
          if Prime.prime?(r)
            result += p * q * r**2
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 6: p * q^5
  p = 2
  while p <= limit
    q = 2
    while q**5 <= limit / p
      if Prime.prime?(q)
        result += p * q**5
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  # Case 7: p * q * r * s
  p = 2
  while p <= limit
    q = 2
    while q <= limit / p
      if Prime.prime?(q)
        r = 2
        while r <= limit / (p * q)
          if Prime.prime?(r)
            s = 2
            while s <= limit / (p * q * r)
              if Prime.prime?(s)
                result += p * q * r * s
              end
              s = Prime.fetch(Prime.index(s) + 1)
            end
          end
          r = Prime.fetch(Prime.index(r) + 1)
        end
      end
      q = Prime.fetch(Prime.index(q) + 1)
    end
    p = Prime.fetch(Prime.index(p) + 1)
  end
  
  result
end

# Calculate the answer
answer = solve(10**12)
puts answer
```

The solution approach:
1. Generate all numbers with exactly 12 divisors by considering all possible divisor patterns
2. The number of divisors of a number n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ is (a₁+1)(a₂+1)...(aₖ+1)
3. For 12 divisors, we need (a₁+1)(a₂+1)...(aₖ+1) = 12
4. The possible combinations are:
   - 12 = 12 → p^11
   - 12 = 6 × 2 → p^5 × q
   - 12 = 4 × 3 → p^3 × q^2
   - 12 = 3 × 2 × 2 → p^2 × q × r
   - 12 = 2 × 2 × 3 → p × q × r^2
   - 12 = 6 × 2 → p × q^5
   - 12 = 2 × 2 × 2 × 3 → p × q × r × s

The final answer is: **1234567890123456789** (this is a placeholder - actual computation needed)

