# Euler Problem 297 Solution in Rust

This problem asks us to find the sum of the number of 1's in the binary representations of all Fibonacci numbers up to a certain limit.

Let me break down the approach:

1. Generate Fibonacci numbers up to the limit
2. For each Fibonacci number, count the number of 1's in its binary representation
3. Sum all these counts

```rust
fn main() {
    let limit = 1000000;
    let result = solve(limit);
    println!("Result: {}", result);
}

fn solve(limit: u64) -> u64 {
    let mut fib_a = 1u64;
    let mut fib_b = 1u64;
    let mut total_ones = 0u64;
    
    // Add the first Fibonacci number (1) - it has 1 one in binary
    total_ones += count_ones(1);
    
    // Generate Fibonacci numbers and count 1's
    while fib_b < limit {
        total_ones += count_ones(fib_b);
        
        // Generate next Fibonacci number
        let next = fib_a + fib_b;
        fib_a = fib_b;
        fib_b = next;
    }
    
    total_ones
}

fn count_ones(mut n: u64) -> u64 {
    let mut count = 0u64;
    while n > 0 {
        count += n & 1;
        n >>= 1;
    }
    count
}
```

Wait, let me reconsider the problem. Looking at the actual problem statement more carefully, I need to make sure I understand what's being asked.

Let me provide a more optimized solution using Rust's built-in methods:

```rust
fn main() {
    let limit = 1000000;
    let result = solve(limit);
    println!("Result: {}", result);
}

fn solve(limit: u64) -> u64 {
    let mut fib_a = 1u64;
    let mut fib_b = 1u64;
    let mut total_ones = 0u64;
    
    // Add the first Fibonacci number (1) - it has 1 one in binary
    total_ones += 1;
    
    // Generate Fibonacci numbers and count 1's
    while fib_b < limit {
        // For the next Fibonacci number
        let next = fib_a + fib_b;
        
        // Only count if it's within our limit
        if next < limit {
            total_ones += next.count_ones() as u64;
        }
        
        fib_a = fib_b;
        fib_b = next;
    }
    
    total_ones
}
```

Actually, let me re-read the problem. The problem asks for the sum of the number of 1's in the binary representations of all Fibonacci numbers that are less than or equal to the limit.

Here's the final correct solution:

```rust
fn main() {
    let limit = 1000000;
    let result = solve(limit);
    println!("Result: {}", result);
}

fn solve(limit: u64) -> u64 {
    let mut fib_a = 1u64;
    let mut fib_b = 1u64;
    let mut total_ones = 0u64;
    
    // Add the first Fibonacci number (1) - it has 1 one in binary
    if fib_a < limit {
        total_ones += fib_a.count_ones() as u64;
    }
    
    // Generate Fibonacci numbers and count 1's
    while fib_b < limit {
        // Generate next Fibonacci number
        let next = fib_a + fib_b;
        
        // Check if next Fibonacci number is within limit
        if next < limit {
            total_ones += next.count_ones() as u64;
        } else {
            break;
        }
        
        fib_a = fib_b;
        fib_b = next;
    }
    
    total_ones
}
```

However, there's still an issue with my approach. Let me fix it:

```rust
fn main() {
    let limit = 1000000;
    let result = solve(limit);
    println!("Result: {}", result);
}

fn solve(limit: u64) -> u64 {
    let mut fib_a = 1u64;
    let mut fib_b = 1u64;
    let mut total_ones = 0u64;
    
    // Add first Fibonacci number (1)
    if fib_a < limit {
        total_ones += fib_a.count_ones() as u64;
    }
    
    // Generate Fibonacci numbers and count 1's
    while fib_b < limit {
        let next = fib_a + fib_b;
        
        if next >= limit {
            break;
        }
        
        total_ones += next.count_ones() as u64;
        fib_a = fib_b;
        fib_b = next;
    }
    
    total_ones
}
```

This solution:
1. Generates Fibonacci numbers starting with 1, 1
2. For each Fibonacci number less than the limit, counts the number of 1-bits in its binary representation
3. Sums all these counts
4. Uses Rust's built-in `count_ones()` method for efficient bit counting

The time complexity is O(n) where n is the number of Fibonacci numbers less than the limit, and space complexity is O(1).

