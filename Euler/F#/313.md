# Euler Problem 313 Solution in F#

## Problem Statement
In a race, the participants are given a set of coins and must find the number of ways to make change for a given amount using those coins. This is a classic dynamic programming problem.

## Solution

```fsharp
let solveEuler313 () =
    // Define the coin denominations (standard US coins)
    let coins = [1; 2; 5; 10; 20; 50; 100; 200]
    
    // Function to count the number of ways to make change
    let countWays target coins =
        let dp = Array.create (target + 1) 0
        dp.[0] <- 1  // One way to make 0 (use no coins)
        
        for coin in coins do
            for i in coin .. target do
                dp.[i] <- dp.[i] + dp.[i - coin]
        
        dp.[target]
    
    // Calculate the number of ways to make 200p (2 pounds)
    countWays 200 coins

// Execute the solution
let result = solveEuler313()
printfn "The number of ways to make 200p using standard coins is: %d" result
```

## Explanation

This solution uses dynamic programming to solve the coin change problem:

1. **Coins Definition**: We define the standard UK coin denominations: 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).

2. **Dynamic Programming Approach**: 
   - Create an array `dp` where `dp[i]` represents the number of ways to make amount `i`
   - Initialize `dp[0] = 1` (one way to make 0)
   - For each coin, update the dp array by adding the number of ways to make `(current_amount - coin)`

3. **Algorithm Complexity**: 
   - Time complexity: O(amount × number_of_coins)
   - Space complexity: O(amount)

## Alternative Implementation

```fsharp
let solveEuler313Alternative () =
    let coins = [1; 2; 5; 10; 20; 50; 100; 200]
    
    let rec countWays target coins =
        match coins with
        | [] -> if target = 0 then 1 else 0
        | coin :: rest ->
            let withoutCoin = countWays target rest
            let withCoin = if target >= coin then countWays (target - coin) coins else 0
            withoutCoin + withCoin
    
    // Using memoization for better performance
    let memo = System.Collections.Generic.Dictionary<int, int>()
    
    let rec countWaysMemo target coins =
        match memo.TryGetValue(target) with
        | (true, value) -> value
        | (false, _) ->
            let result = 
                match coins with
                | [] -> if target = 0 then 1 else 0
                | coin :: rest ->
                    let withoutCoin = countWaysMemo target rest
                    let withCoin = if target >= coin then countWaysMemo (target - coin) coins else 0
                    withoutCoin + withCoin
            memo.[target] <- result
            result
    
    countWaysMemo 200 coins

// Run the alternative solution
let result2 = solveEuler313Alternative()
printfn "Alternative solution result: %d" result2
```

## Result

The solution returns **73682** ways to make 200p using the standard UK coin denominations.

This is a classic dynamic programming problem that demonstrates the power of bottom-up approach in solving combinatorial counting problems.

