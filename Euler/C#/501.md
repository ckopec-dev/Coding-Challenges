# Euler Problem 501 Solution in C#

I'll solve Project Euler Problem 501, which asks for the number of integers n ≤ 10^12 such that n has exactly 8 divisors.

## Problem Analysis

For a number n to have exactly 8 divisors, its prime factorization must follow one of these forms:
1. n = p^7 (one prime to the 7th power)
2. n = p^3 × q (one prime cubed, another prime)
3. n = p × q × r (three distinct primes)
4. n = p^6 × q (one prime to the 6th power, another prime)
5. n = p^2 × q^2 (two primes squared)
6. n = p^5 × q (one prime to the 5th power, another prime)
7. n = p^4 × q^2 (one prime to the 4th power, another prime squared)
8. n = p^2 × q × r (one prime squared, two other primes)

Actually, let me reconsider the divisor formula. If n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, then the number of divisors is (a₁+1)(a₂+1)...(aₖ+1).

For exactly 8 divisors, we need (a₁+1)(a₂+1)...(aₖ+1) = 8.

The factorizations of 8 are:
- 8 = 8 (so n = p^7)
- 8 = 4 × 2 (so n = p^3 × q)
- 8 = 2 × 2 × 2 (so n = p × q × r)

So we need to count numbers of the form:
1. p^7
2. p^3 × q  
3. p × q × r

## C# Solution

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Euler501
{
    private static List<long> primes;
    private static long limit = 1000000000000L; // 10^12
    
    public static void Main()
    {
        // Generate primes up to sqrt(limit)
        GeneratePrimes();
        
        long result = CountNumbersWithEightDivisors();
        Console.WriteLine($"Answer: {result}");
    }
    
    private static void GeneratePrimes()
    {
        // Sieve of Eratosthenes to generate primes up to sqrt(limit)
        int maxPrime = (int)Math.Sqrt(limit) + 1000;
        bool[] isPrime = new bool[maxPrime + 1];
        for (int i = 2; i <= maxPrime; i++)
            isPrime[i] = true;
            
        for (int i = 2; i * i <= maxPrime; i++)
        {
            if (isPrime[i])
            {
                for (int j = i * i; j <= maxPrime; j += i)
                    isPrime[j] = false;
            }
        }
        
        primes = new List<long>();
        for (int i = 2; i <= maxPrime; i++)
        {
            if (isPrime[i])
                primes.Add(i);
        }
    }
    
    private static long CountNumbersWithEightDivisors()
    {
        long count = 0;
        
        // Case 1: n = p^7
        count += CountPowersOfPrimes(7);
        
        // Case 2: n = p^3 × q
        count += CountP3Q();
        
        // Case 3: n = p × q × r
        count += CountPQR();
        
        return count;
    }
    
    private static long CountPowersOfPrimes(int power)
    {
        long count = 0;
        foreach (long p in primes)
        {
            long n = (long)Math.Pow(p, power);
            if (n > limit) break;
            count++;
        }
        return count;
    }
    
    private static long CountP3Q()
    {
        long count = 0;
        int primeCount = primes.Count;
        
        // For each prime p, find primes q such that p^3 * q <= limit
        for (int i = 0; i < primeCount; i++)
        {
            long p = primes[i];
            long p3 = p * p * p;
            
            if (p3 > limit) break;
            
            // Find how many primes q exist such that p^3 * q <= limit
            long maxQ = limit / p3;
            
            // Binary search for the count of primes <= maxQ
            int left = i + 1;
            int right = primeCount - 1;
            int result = i;
            
            while (left <= right)
            {
                int mid = left + (right - left) / 2;
                if (primes[mid] <= maxQ)
                {
                    result = mid;
                    left = mid + 1;
                }
                else
                {
                    right = mid - 1;
                }
            }
            
            count += result - i;
        }
        
        return count;
    }
    
    private static long CountPQR()
    {
        long count = 0;
        int primeCount = primes.Count;
        
        // For each pair of primes (p, q), find primes r such that p * q * r <= limit
        for (int i = 0; i < primeCount; i++)
        {
            long p = primes[i];
            long maxPQ = limit / p;
            
            for (int j = i + 1; j < primeCount; j++)
            {
                long q = primes[j];
                long pq = p * q;
                
                if (pq > maxPQ) break;
                
                long maxR = maxPQ / q;
                
                // Count primes r > q and r <= maxR
                int left = j + 1;
                int right = primeCount - 1;
                int result = j;
                
                while (left <= right)
                {
                    int mid = left + (right - left) / 2;
                    if (primes[mid] <= maxR)
                    {
                        result = mid;
                        left = mid + 1;
                    }
                    else
                    {
                        right = mid - 1;
                    }
                }
                
                count += result - j;
            }
        }
        
        return count;
    }
}
```

Wait, let me reconsider the problem more carefully and provide a cleaner approach:

```csharp
using System;
using System.Collections.Generic;

public class Euler501
{
    private static List<long> primes;
    private static long limit = 1000000000000L; // 10^12
    
    public static void Main()
    {
        GeneratePrimes();
        long result = Solve();
        Console.WriteLine($"Answer: {result}");
    }
    
    private static void GeneratePrimes()
    {
        // Generate primes up to a reasonable limit
        int maxPrime = 1000000;
        bool[] isPrime = new bool[maxPrime + 1];
        for (int i = 2; i <= maxPrime; i++)
            isPrime[i] = true;
            
        for (int i = 2; i * i <= maxPrime; i++)
        {
            if (isPrime[i])
            {
                for (int j = i * i; j <= maxPrime; j += i)
                    isPrime[j] = false;
            }
        }
        
        primes = new List<long>();
        for (int i = 2; i <= maxPrime; i++)
        {
            if (isPrime[i])
                primes.Add(i);
        }
    }
    
    private static long Solve()
    {
        long count = 0;
        
        // Case 1: n = p^7
        count += CountP7();
        
        // Case 2: n = p^3 × q  
        count += CountP3Q();
        
        // Case 3: n = p × q × r
        count += CountPQR();
        
        return count;
    }
    
    private static long CountP7()
    {
        long count = 0;
        foreach (long p in primes)
        {
            long n = p * p * p * p * p * p * p;
            if (n > limit) break;
            count++;
        }
        return count;
    }
    
    private static long CountP3Q()
    {
        long count = 0;
        int primeCount = primes.Count;
        
        for (int i = 0; i < primeCount; i++)
        {
            long p = primes[i];
            long p3 = p * p * p;
            
            if (p3 > limit) break;
            
            long maxQ = limit / p3;
            
            // Count primes q > p and q <= maxQ
            for (int j = i + 1; j < primeCount; j++)
            {
                if (primes[j] > maxQ) break;
                count++;
            }
        }
        
        return count;
    }
    
    private static long CountPQR()
    {
        long count = 0;
        int primeCount = primes.Count;
        
        for (int i = 0; i < primeCount; i++)
        {
            long p = primes[i];
            long maxPQ = limit / p;
            
            for (int j = i + 1; j < primeCount; j++)
            {
                long q = primes[j];
                long pq = p * q;
                
                if (pq > maxPQ) break;
                
                long maxR = maxPQ / q;
                
                // Count primes r > q and r <= maxR
                for (int k = j + 1; k < primeCount; k++)
                {
                    if (primes[k] > maxR) break;
                    count++;
                }
            }
        }
        
        return count;
    }
}
```

Actually, let me write a cleaner, more efficient version:

```csharp
using System;
using System.Collections.Generic;

public class Euler501
{
    private static List<long> primes;
    private static long limit = 1000000000000L; // 10^12
    
    public static void Main()
    {
        GeneratePrimes();
        long result = Solve();
        Console.WriteLine($"Answer: {result}");
    }
    
    private static void GeneratePrimes()
    {
        // Sieve of Eratosthenes for primes up to sqrt(limit)
        int maxPrime = (int)Math.Sqrt(limit) + 10000;
        bool[] isPrime = new bool[maxPrime + 1];
        for (int i = 2; i <= maxPrime; i++)
            isPrime[i] = true;
            
        for (int i = 2; i * i <= maxPrime; i++)
        {
            if (isPrime[i])
            {
                for (int j = i * i; j <= maxPrime; j += i)
                    isPrime[j] = false;
            }
        }
        
        primes = new List<long>();
        for (int i = 2; i <= maxPrime; i++)
        {
            if (isPrime[i])
                primes.Add(i);
        }
    }
    
    private static long Solve()
    {
        long count = 0;
        
        // Case 1: n = p^7
        count += CountP7();
        
        // Case 2: n = p^3 × q  
        count += CountP3Q();
        
        // Case 3: n = p × q × r
        count += CountPQR();
        
        return count;
    }
    
    private static long CountP7()
    {
        long count = 0;
        foreach (long p in primes)
        {
            long n = (long)Math.Pow(p, 7);
            if (n > limit) break;
            count++;
        }
        return count;
    }
    
    private static long CountP3Q()
    {
        long count = 0;
        int primeCount = primes.Count;
        
        for (int i = 0; i < primeCount; i++)
        {
            long p = primes[i];
            long p3 = p * p * p;
            
            if (p3 > limit) break;
            
            long maxQ = limit / p3;
            
            // Count primes q > p and q <= maxQ
            for (int j = i + 1; j < primeCount; j++)
            {
                if (primes[j] > maxQ) break;
                count++;
            }
        }
        
        return count;
    }
    
    private static long CountPQR()
    {
        long count = 0;
        int primeCount = primes.Count;
        
        for (int i = 0; i < primeCount; i++)
        {
            long p = primes[i];
            long maxPQ = limit / p;
            
            for (int j = i + 1; j < primeCount; j++)
            {
                long q = primes[j];
                long pq = p * q;
                
                if (pq > maxPQ) break;
                
                long maxR = maxPQ / q;
                
                // Count primes r > q and r <= maxR
                for (int k = j + 1; k < primeCount; k++)
                {
                    if (primes[k] > maxR) break;
                    count++;
                }
            }
        }
        
        return count;
    }
}
```

This solution counts numbers with exactly 8 divisors by considering the three possible forms:
1. p^7 (one prime to the 7th power)
2. p^3 × q (one prime cubed, another prime)  
3. p × q × r (three distinct primes)

The algorithm uses the Sieve of Eratosthenes to generate primes efficiently and then counts valid combinations for each case.

