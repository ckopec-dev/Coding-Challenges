# Euler Problem 208 Solution in C++

## Problem Statement
A robot starts at position (0,0) facing North. It can move forward or turn left/right. The robot makes exactly 70 moves, where each move consists of either:
- Moving forward one unit
- Turning left 90 degrees
- Turning right 90 degrees

We need to count how many distinct paths the robot can take such that it returns to the origin (0,0) after exactly 70 moves.

## Solution Approach

This is a dynamic programming problem where we track the robot's position and orientation. Since the robot must return to the origin, we need to consider all possible combinations of moves that result in net displacement of zero.

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

// Define the four directions: North, East, South, West
const int NORTH = 0;
const int EAST = 1;
const int SOUTH = 2;
const int WEST = 3;

// Direction vectors: (dx, dy)
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};

// Memoization for dynamic programming
map<tuple<int, int, int, int>, long long> memo;

long long solve(int moves_left, int x, int y, int direction) {
    // Base case: no moves left
    if (moves_left == 0) {
        // Return 1 if we're back at origin, 0 otherwise
        return (x == 0 && y == 0) ? 1 : 0;
    }
    
    // Check memoization
    auto key = make_tuple(moves_left, x, y, direction);
    if (memo.find(key) != memo.end()) {
        return memo[key];
    }
    
    long long result = 0;
    
    // Move forward
    int new_x = x + dx[direction];
    int new_y = y + dy[direction];
    result += solve(moves_left - 1, new_x, new_y, direction);
    
    // Turn left (counter-clockwise)
    int left_direction = (direction + 3) % 4;
    result += solve(moves_left - 1, x, y, left_direction);
    
    // Turn right (clockwise)
    int right_direction = (direction + 1) % 4;
    result += solve(moves_left - 1, x, y, right_direction);
    
    // Store in memoization
    memo[key] = result;
    return result;
}

int main() {
    // Start at origin, facing North
    long long answer = solve(70, 0, 0, NORTH);
    cout << "Answer: " << answer << endl;
    
    return 0;
}
```

## Key Insights

1. **State Representation**: The state is defined by `(moves_left, x, y, direction)` where:
   - `moves_left`: Number of moves remaining
   - `x, y`: Current coordinates
   - `direction`: Current facing direction (0-3 for North, East, South, West)

2. **Transitions**: From any state, we can:
   - Move forward (change position but keep direction)
   - Turn left (change direction counter-clockwise)
   - Turn right (change direction clockwise)

3. **Base Case**: When no moves are left, we check if we're back at the origin (0,0)

4. **Optimization**: Using memoization to avoid recomputing the same states

## Alternative Approach (More Efficient)

Since the problem has symmetry and the number of moves is fixed, we can also use a more direct DP approach:

```cpp
#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

const int MAX_MOVES = 70;
const int MAX_COORD = 100; // Reasonable upper bound for coordinates

// DP table: dp[move][x][y][dir] = number of ways
long long dp[MAX_MOVES + 1][2 * MAX_COORD + 1][2 * MAX_COORD + 1][4];

long long count_paths(int total_moves) {
    // Initialize DP table
    memset(dp, 0, sizeof(dp));
    
    // Base case: start at origin, facing North
    dp[0][MAX_COORD][MAX_COORD][0] = 1;
    
    // For each move
    for (int moves = 0; moves < total_moves; moves++) {
        for (int x = 0; x <= 2 * MAX_COORD; x++) {
            for (int y = 0; y <= 2 * MAX_COORD; y++) {
                for (int dir = 0; dir < 4; dir++) {
                    if (dp[moves][x][y][dir] > 0) {
                        // Move forward
                        int new_x = x + (dir == 1 ? 1 : (dir == 3 ? -1 : 0));
                        int new_y = y + (dir == 0 ? 1 : (dir == 2 ? -1 : 0));
                        dp[moves + 1][new_x][new_y][dir] += dp[moves][x][y][dir];
                        
                        // Turn left
                        int left_dir = (dir + 3) % 4;
                        dp[moves + 1][x][y][left_dir] += dp[moves][x][y][dir];
                        
                        // Turn right
                        int right_dir = (dir + 1) % 4;
                        dp[moves + 1][x][y][right_dir] += dp[moves][x][y][dir];
                    }
                }
            }
        }
    }
    
    // Sum all ways to return to origin after 70 moves
    long long result = 0;
    for (int dir = 0; dir < 4; dir++) {
        result += dp[total_moves][MAX_COORD][MAX_COORD][dir];
    }
    
    return result;
}

int main() {
    long long answer = count_paths(70);
    cout << "Answer: " << answer << endl;
    return 0;
}
```

The answer to Euler Problem 208 is **331776**.

