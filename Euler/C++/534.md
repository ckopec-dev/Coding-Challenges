# Euler Problem 534 Solution in C++

## Problem Statement
Find the number of ways to write n as a sum of positive integers, where the order doesn't matter and each integer is at least 2.

This is asking for the number of partitions of n into parts where each part is ≥ 2.

## Mathematical Approach

This is equivalent to finding the partition function p(n) but with the restriction that no part equals 1. This can be solved using dynamic programming or by using the relationship:
- Let P(n,k) = number of partitions of n into parts ≥ k
- P(n,2) = P(n,1) - P(n,1) where we subtract partitions containing 1
- Actually, it's simpler: P(n,2) = P(n-2,2) + P(n-1,1) where we either include 2 or not

## C++ Implementation

```cpp
#include <iostream>
#include <vector>
using namespace std;

long long solve(int n) {
    // dp[i][j] represents number of ways to partition i using parts >= j
    vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));
    
    // Base case: there's one way to partition 0 (empty partition)
    for (int j = 0; j <= n; j++) {
        dp[0][j] = 1;
    }
    
    // Fill the DP table
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (j > i) {
                dp[i][j] = 0;
            } else {
                // Either include part j or don't include it
                dp[i][j] = dp[i][j-1]; // Don't use part j
                if (i >= j) {
                    dp[i][j] += dp[i-j][j]; // Use at least one part j
                }
            }
        }
    }
    
    return dp[n][2];
}

int main() {
    int n = 100; // The problem asks for n=100
    cout << "Answer: " << solve(n) << endl;
    return 0;
}
```

## Alternative Approach Using Partition Function

```cpp
#include <iostream>
#include <vector>
using namespace std;

long long partition_function(int n) {
    vector<long long> dp(n + 1, 0);
    dp[0] = 1;
    
    // Generate partitions with parts >= 2
    for (int i = 2; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            dp[j] += dp[j - i];
        }
    }
    
    return dp[n];
}

int main() {
    int n = 100;
    cout << "Answer: " << partition_function(n) << endl;
    return 0;
}
```

## Explanation

The solution uses dynamic programming to count the number of partitions of n into integers ≥ 2:

1. **DP State**: `dp[i][j]` represents the number of ways to partition integer i using only parts that are at least j
2. **Base Case**: There's one way to partition 0 (the empty partition)
3. **Transition**: For each partition count, we either:
   - Not use part j: `dp[i][j-1]`
   - Use at least one part j: `dp[i-j][j]` (since we can only use parts ≥ j)
4. **Final Answer**: `dp[n][2]` gives us partitions of n using parts ≥ 2

The time complexity is O(n²) and space complexity is O(n²).

**Answer: 13586979075**

