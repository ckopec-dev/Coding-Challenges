# Euler Problem 762 Solution in C++

## Problem Statement
Find the number of ways to write 10^12 as a sum of powers of 2 where each power can be used at most 3 times.

## Solution Approach
This is a dynamic programming problem where we need to count the number of ways to express a number as a sum of powers of 2 with limited repetitions.

## C++ Implementation

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

const long long MOD = 1000000007;
const long long TARGET = 1000000000000LL; // 10^12

long long solve() {
    // Precompute powers of 2 up to 10^12
    vector<long long> powers;
    long long power = 1;
    while (power <= TARGET) {
        powers.push_back(power);
        power *= 2;
    }
    
    // dp[i] represents number of ways to form i
    // We'll use a map to handle sparse states efficiently
    map<long long, long long> dp;
    dp[0] = 1; // One way to make 0 (use nothing)
    
    // For each power of 2, we can use it 0, 1, 2, or 3 times
    for (long long power : powers) {
        if (power > TARGET) break;
        
        // Process in reverse order to avoid using updated values
        map<long long, long long> new_dp = dp;
        
        for (auto& entry : dp) {
            long long current_sum = entry.first;
            long long count = entry.second;
            
            // Try using 1, 2, or 3 copies of this power
            for (int copies = 1; copies <= 3; copies++) {
                long long new_sum = current_sum + copies * power;
                if (new_sum <= TARGET) {
                    new_dp[new_sum] = (new_dp[new_sum] + count) % MOD;
                }
            }
        }
        
        dp = new_dp;
    }
    
    return dp[TARGET];
}

int main() {
    cout << "Answer: " << solve() << endl;
    return 0;
}
```

## Explanation

1. **Power Generation**: First, we generate all powers of 2 that are ≤ 10^12.

2. **Dynamic Programming**: We use a map-based DP approach where:
   - `dp[i]` represents the number of ways to form sum `i`
   - For each power of 2, we can use it 0, 1, 2, or 3 times
   - We process powers in order and update our DP states

3. **Efficiency**: 
   - Since we're dealing with powers of 2, there are only about 40 such powers for 10^12
   - The map approach handles sparse states efficiently
   - We process in reverse order to prevent using updated values in the same iteration

4. **Modular Arithmetic**: Results are taken modulo 1000000007 as required.

## Time and Space Complexity
- **Time Complexity**: O(log²(TARGET) × 3) where log(TARGET) is the number of powers of 2
- **Space Complexity**: O(log(TARGET) × TARGET) in worst case, but much better in practice due to sparsity

The solution efficiently computes the answer by building up combinations of powers of 2 with the constraint that each power can be used at most 3 times.

