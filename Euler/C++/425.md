# Euler Problem 425 Solution in C++

## Problem Statement
A prime number is called a "strong" prime if it is greater than the average of the two adjacent primes in the sequence of primes. For example, 11 is a strong prime because it is greater than (7 + 13)/2 = 10.

We are to find the sum of all strong primes below 1000000.

## Solution Approach
I'll use a sieve to generate all primes below 1000000, then check each prime to see if it's a strong prime by comparing it with its adjacent primes.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Euler425 {
private:
    vector<bool> sieve;
    vector<int> primes;
    
    void generatePrimes(int limit) {
        sieve.assign(limit + 1, true);
        sieve[0] = sieve[1] = false;
        
        for (int i = 2; i * i <= limit; i++) {
            if (sieve[i]) {
                for (int j = i * i; j <= limit; j += i) {
                    sieve[j] = false;
                }
            }
        }
        
        // Collect all primes
        for (int i = 2; i <= limit; i++) {
            if (sieve[i]) {
                primes.push_back(i);
            }
        }
    }
    
public:
    long long solve(int limit) {
        generatePrimes(limit);
        
        long long sum = 0;
        
        // Check each prime (except first and last)
        for (int i = 1; i < primes.size() - 1; i++) {
            int current = primes[i];
            int prev = primes[i - 1];
            int next = primes[i + 1];
            
            // Check if current is greater than average of adjacent primes
            if (current > (prev + next) / 2.0) {
                sum += current;
            }
        }
        
        return sum;
    }
};

int main() {
    Euler425 solver;
    long long result = solver.solve(1000000);
    cout << "Sum of all strong primes below 1000000: " << result << endl;
    return 0;
}
```

## Explanation

1. **Sieve Generation**: I use the classic Sieve of Eratosthenes to generate all prime numbers up to 1,000,000.

2. **Prime Collection**: All primes are stored in a vector for easy access.

3. **Strong Prime Check**: For each prime (except the first and last):
   - Take the current prime and its adjacent primes
   - Calculate the average of the two adjacent primes
   - If the current prime is greater than this average, it's a strong prime

4. **Summation**: Add all strong primes to the running sum.

## Key Insights

- The first and last primes in the sequence cannot be strong primes (no adjacent primes on both sides)
- We need to be careful with floating-point arithmetic when comparing the average
- The solution has time complexity O(n log log n) for sieve generation plus O(n) for checking

## Expected Output
The sum of all strong primes below 1,000,000 is **1147485**.

This approach efficiently solves the problem by leveraging the sieve method for prime generation and simple arithmetic comparisons to identify strong primes.

