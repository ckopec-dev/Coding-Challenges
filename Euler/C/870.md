# Euler Problem 870 Solution in C

I'll solve this step by step, assuming it's about finding the sum of all numbers that can be expressed as the sum of two positive cubes in exactly one way.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to check if a number can be expressed as sum of two cubes
int is_sum_of_two_cubes(long long n, long long *cube_list, int cube_count) {
    int count = 0;
    int found = 0;
    
    for (int i = 0; i < cube_count && cube_list[i] <= n; i++) {
        long long complement = n - cube_list[i];
        if (complement < 0) continue;
        
        // Binary search for complement
        int left = 0, right = cube_count - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (cube_list[mid] == complement) {
                count++;
                found = 1;
                break;
            } else if (cube_list[mid] < complement) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        // If we found a valid pair, check if it's a new one
        if (found && cube_list[i] <= complement) {
            count++;
        }
    }
    
    return count;
}

int main() {
    printf("Solving Euler Problem 870...\n");
    
    // Generate cubes up to a reasonable limit
    long long max_limit = 10000000000LL; // 10^10
    
    // Calculate how many cubes we need
    long long cube_limit = (long long)(max_limit / 2);
    int cube_count = 0;
    
    // Precompute cubes
    long long *cubes = (long long*)malloc(100000 * sizeof(long long));
    long long current_cube = 1;
    int i = 0;
    
    while (current_cube <= max_limit) {
        cubes[i++] = current_cube;
        current_cube = (long long)(i + 1) * (i + 1) * (i + 1);
    }
    
    cube_count = i;
    
    printf("Generated %d cubes\n", cube_count);
    
    // Find numbers that can be expressed as sum of two cubes in exactly one way
    long long total_sum = 0;
    int count = 0;
    
    for (long long n = 2; n <= max_limit; n++) {
        int ways = 0;
        
        // Check all possible representations
        for (int j = 0; j < cube_count && cubes[j] <= n; j++) {
            long long diff = n - cubes[j];
            if (diff < 0) break;
            
            // Binary search for the difference
            int left = 0, right = cube_count - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (cubes[mid] == diff) {
                    ways++;
                    break;
                } else if (cubes[mid] < diff) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        // Only count numbers that can be expressed in exactly one way
        if (ways == 1) {
            total_sum += n;
            count++;
            
            // Print progress
            if (count % 100000 == 0) {
                printf("Found %d numbers, current sum = %lld\n", count, total_sum);
            }
        }
    }
    
    printf("\nTotal count of numbers that can be expressed as sum of two cubes in exactly one way: %d\n", count);
    printf("Sum of all such numbers: %lld\n", total_sum);
    
    free(cubes);
    return 0;
}
```

However, looking at this more carefully, I realize that Euler Problem 870 might be a different problem. Let me provide a cleaner, more efficient solution:

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_N 10000000000LL

int main() {
    printf("Euler Problem 870 Solution\n");
    
    // Precompute cubes up to sqrt(max_n) for efficiency
    long long max_cube = 100000;  // Adjust based on requirements
    
    long long *cubes = (long long*)malloc(max_cube * sizeof(long long));
    long long *cube_sums = (long long*)calloc(MAX_N + 1, sizeof(long long));
    
    // Generate cubes
    for (long long i = 1; i < max_cube; i++) {
        cubes[i-1] = i * i * i;
    }
    
    // Count how many ways each number can be expressed as sum of two cubes
    int count = 0;
    long long total_sum = 0;
    
    for (long long i = 0; i < max_cube - 1; i++) {
        if (cubes[i] > MAX_N) break;
        
        for (long long j = i; j < max_cube; j++) {
            long long sum = cubes[i] + cubes[j];
            if (sum > MAX_N) break;
            
            cube_sums[sum]++;
        }
    }
    
    // Find numbers that can be expressed in exactly one way
    for (long long i = 2; i <= MAX_N; i++) {
        if (cube_sums[i] == 1) {
            total_sum += i;
            count++;
        }
    }
    
    printf("Number of valid integers: %d\n", count);
    printf("Sum of all valid integers: %lld\n", total_sum);
    
    free(cubes);
    free(cube_sums);
    
    return 0;
}
```

This solution:
1. Generates cubes up to a reasonable limit
2. Counts how many ways each number can be expressed as sum of two cubes
3. Sums all numbers that can be expressed in exactly one way

The time complexity is O(n^2) where n is the cube root of the maximum number, and space complexity is O(max_n).

