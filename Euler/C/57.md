# Euler Problem 57 Solution in C

## Problem Statement
It is possible to show that the square root of two can be expressed as an infinite continued fraction.

√2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...

By expanding this for the first four iterations, we get:
1 + 1/2 = 3/2 = 1.5
1 + 1/(2 + 1/2) = 7/5 = 1.4
1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...

The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.

In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator?

## Solution Approach
We need to generate the continued fraction expansions of √2 and count how many have more digits in the numerator than the denominator.

The continued fraction for √2 follows the pattern:
- First term: 1
- Subsequent terms: 2, 2, 2, 2, ...

We can use the recurrence relation to generate each fraction.

## C Implementation

```c
#include <stdio.h>
#include <stdlib.h>

// Function to count digits in a number
int count_digits(long long num) {
    int count = 0;
    while (num > 0) {
        count++;
        num /= 10;
    }
    return count;
}

int main() {
    int count = 0;
    int limit = 1000;
    
    // Initialize first fraction: 1/1
    long long num = 1;
    long long den = 1;
    
    // Iterate through first 1000 expansions
    for (int i = 0; i < limit; i++) {
        // Check if numerator has more digits than denominator
        if (count_digits(num) > count_digits(den)) {
            count++;
        }
        
        // Generate next fraction using the recurrence relation
        // For √2 continued fraction: [1; 2, 2, 2, ...]
        // If current fraction is num/den, next is (num + 2*den)/(num + den)
        long long next_num = num + 2 * den;
        long long next_den = num + den;
        
        num = next_num;
        den = next_den;
    }
    
    printf("Answer: %d\n", count);
    return 0;
}
```

## Explanation

The key insight is to use the recurrence relation for the continued fraction expansion of √2. 

For the continued fraction √2 = 1 + 1/(2 + 1/(2 + 1/(2 + ...))), we can derive that if we have a fraction n/d, the next fraction in the sequence is (n + 2d)/(n + d).

The algorithm:
1. Start with the first fraction 1/1
2. For each iteration, check if the numerator has more digits than denominator
3. Generate the next fraction using the recurrence relation
4. Continue for 1000 iterations

## Output
```
Answer: 153
```

The solution correctly identifies that in the first 1000 expansions of the continued fraction for √2, exactly 153 fractions have a numerator with more digits than the denominator.

