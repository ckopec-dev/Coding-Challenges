# Euler Problem 823 Solution in C

I'll solve this step by step, breaking down the problem and implementing it in C.

## Problem Understanding

Euler Problem 823 asks us to find the sum of all positive integers n ≤ 10^15 such that n has exactly 12 divisors and n is divisible by 12.

## Mathematical Analysis

Let's analyze what it means for n to have exactly 12 divisors:
- If n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ, then the number of divisors is (a₁+1)(a₂+1)...(aₖ+1) = 12
- The possible factorizations of 12 are: 12, 6×2, 4×3, 3×2×2

This gives us the possible forms for n:
1. n = p¹¹ (12 divisors)
2. n = p⁵ × q¹ (12 divisors)  
3. n = p³ × q² (12 divisors)
4. n = p² × q¹ × r¹ (12 divisors)

## Implementation Strategy

1. Generate all possible combinations of the forms above
2. Check if the resulting number is divisible by 12
3. Sum all valid numbers ≤ 10^15

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Function to check if a number is prime
int is_prime(long long n) {
    if (n <= 1) return 0;
    if (n <= 3) return 1;
    if (n % 2 == 0 || n % 3 == 0) return 0;
    
    for (long long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return 0;
        }
    }
    return 1;
}

// Function to compute power
long long power(long long base, int exp) {
    long long result = 1;
    for (int i = 0; i < exp; i++) {
        result *= base;
    }
    return result;
}

// Function to check if a number is divisible by 12
int is_divisible_by_12(long long n) {
    return (n % 12 == 0);
}

// Generate numbers of the form p^11
long long generate_p11(long long p) {
    return power(p, 11);
}

// Generate numbers of the form p^5 * q^1
long long generate_p5q1(long long p, long long q) {
    return power(p, 5) * q;
}

// Generate numbers of the form p^3 * q^2
long long generate_p3q2(long long p, long long q) {
    return power(p, 3) * power(q, 2);
}

// Generate numbers of the form p^2 * q^1 * r^1
long long generate_p2qr(long long p, long long q, long long r) {
    return power(p, 2) * q * r;
}

// Main function to solve the problem
long long solve() {
    long long sum = 0;
    long long limit = 1000000000000000LL; // 10^15
    
    // Generate primes up to a reasonable limit
    int primes[100000];
    int prime_count = 0;
    
    for (long long i = 2; i < 1000000; i++) {
        if (is_prime(i)) {
            primes[prime_count++] = (int)i;
        }
    }
    
    // Check form 1: p^11
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        long long n = generate_p11(primes[i]);
        if (n > limit) break;
        if (is_divisible_by_12(n)) {
            sum += n;
        }
    }
    
    // Check form 2: p^5 * q^1
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        for (int j = 0; j < prime_count; j++) {
            if (primes[i] == primes[j]) continue;
            long long n = generate_p5q1(primes[i], primes[j]);
            if (n > limit) break;
            if (is_divisible_by_12(n)) {
                sum += n;
            }
        }
    }
    
    // Check form 3: p^3 * q^2
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        for (int j = 0; j < prime_count; j++) {
            if (primes[i] == primes[j]) continue;
            long long n = generate_p3q2(primes[i], primes[j]);
            if (n > limit) break;
            if (is_divisible_by_12(n)) {
                sum += n;
            }
        }
    }
    
    // Check form 4: p^2 * q^1 * r^1
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        for (int j = 0; j < prime_count; j++) {
            if (primes[i] == primes[j]) continue;
            for (int k = 0; k < prime_count; k++) {
                if (primes[i] == primes[k] || primes[j] == primes[k]) continue;
                long long n = generate_p2qr(primes[i], primes[j], primes[k]);
                if (n > limit) break;
                if (is_divisible_by_12(n)) {
                    sum += n;
                }
            }
        }
    }
    
    return sum;
}

int main() {
    printf("Solving Euler Problem 823...\n");
    long long result = solve();
    printf("Sum of all positive integers n ≤ 10^15 with exactly 12 divisors and divisible by 12: %lld\n", result);
    return 0;
}
```

Wait, let me reconsider this approach as it might be inefficient. Let me optimize:

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Function to check if a number is prime
int is_prime(long long n) {
    if (n <= 1) return 0;
    if (n <= 3) return 1;
    if (n % 2 == 0 || n % 3 == 0) return 0;
    
    for (long long i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return 0;
        }
    }
    return 1;
}

// Function to compute power
long long power(long long base, int exp) {
    long long result = 1;
    for (int i = 0; i < exp; i++) {
        result *= base;
    }
    return result;
}

// Function to check if a number is divisible by 12
int is_divisible_by_12(long long n) {
    return (n % 12 == 0);
}

// Generate primes up to a limit
void generate_primes(int *primes, int *count, int limit) {
    *count = 0;
    for (long long i = 2; i <= limit; i++) {
        if (is_prime(i)) {
            primes[(*count)++] = (int)i;
        }
    }
}

// Main function to solve the problem
long long solve() {
    long long sum = 0;
    long long limit = 1000000000000000LL; // 10^15
    
    // Generate primes up to 1000000
    int primes[100000];
    int prime_count;
    generate_primes(primes, &prime_count, 1000000);
    
    // Check form 1: p^11
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        long long n = power(primes[i], 11);
        if (n > limit) break;
        if (is_divisible_by_12(n)) {
            sum += n;
        }
    }
    
    // Check form 2: p^5 * q^1
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        for (int j = 0; j < prime_count; j++) {
            if (primes[i] == primes[j]) continue;
            long long n = power(primes[i], 5) * primes[j];
            if (n > limit) break;
            if (is_divisible_by_12(n)) {
                sum += n;
            }
        }
    }
    
    // Check form 3: p^3 * q^2
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        for (int j = 0; j < prime_count; j++) {
            if (primes[i] == primes[j]) continue;
            long long n = power(primes[i], 3) * power(primes[j], 2);
            if (n > limit) break;
            if (is_divisible_by_12(n)) {
                sum += n;
            }
        }
    }
    
    // Check form 4: p^2 * q^1 * r^1
    for (int i = 0; i < prime_count && primes[i] <= 1000000; i++) {
        for (int j = 0; j < prime_count; j++) {
            if (primes[i] == primes[j]) continue;
            for (int k = 0; k < prime_count; k++) {
                if (primes[i] == primes[k] || primes[j] == primes[k]) continue;
                long long n = power(primes[i], 2) * primes[j] * primes[k];
                if (n > limit) break;
                if (is_divisible_by_12(n)) {
                    sum += n;
                }
            }
        }
    }
    
    return sum;
}

int main() {
    printf("Solving Euler Problem 823...\n");
    long long result = solve();
    printf("Sum of all positive integers n ≤ 10^15 with exactly 12 divisors and divisible by 12: %lld\n", result);
    return 0;
}
```

This solution:
1. Generates prime numbers up to 1,000,000
2. Checks all possible forms that yield exactly 12 divisors:
   - p^11
   - p^5 × q^1  
   - p^3 × q^2
   - p^2 × q^1 × r^1
3. For each valid number, checks if it's divisible by 12
4. Sums all qualifying numbers up to 10^15

The time complexity is manageable due to the limited prime generation and the constraint on the maximum value.

