# Euler Problem 84 Solution in Lua

This problem asks us to find the most likely three-square sequence when rolling two dice and moving around a Monopoly board.

```lua
-- Euler Problem 84 Solution
-- Simulate Monopoly game to find most visited squares

math.randomseed(os.time())

-- Define the Monopoly board
local board = {
    "GO", "A1", "CC1", "A2", "T1", "R1", "B1", "CH1", "B2", "B3", 
    "JAIL", "C1", "U1", "C2", "C3", "R2", "D1", "CC2", "D2", "D3",
    "FP", "E1", "CH2", "E2", "E3", "R3", "F1", "F2", "U2", "F3",
    "G2J", "G1", "G2", "CC3", "G3", "R4", "CH3", "H1", "T2", "H2"
}

local board_size = #board
local num_simulations = 1000000
local visit_count = {}

-- Initialize visit count for all squares
for i = 1, board_size do
    visit_count[i] = 0
end

-- Community Chest cards (14 out of 16)
local cc_cards = {1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-- Chance cards (16 out of 16)
local ch_cards = {1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0}

-- Function to get a random card from deck
local function get_card(deck)
    local index = math.random(1, #deck)
    return deck[index]
end

-- Function to simulate dice roll
local function roll_dice()
    local die1 = math.random(1, 4)
    local die2 = math.random(1, 4)
    return die1 + die2
end

-- Function to get next CC card
local function next_cc_card(position)
    local card = get_card(cc_cards)
    if card == 1 then
        return 1  -- Go to GO
    elseif card == 2 then
        return 11 -- Go to JAIL
    else
        return position
    end
end

-- Function to get next CH card
local function next_ch_card(position)
    local card = get_card(ch_cards)
    if card == 1 then
        return 1  -- Go to GO
    elseif card == 2 then
        return 11 -- Go to JAIL
    elseif card == 3 then
        return 24 -- Go to C1
    elseif card == 4 then
        return 11 -- Go to E3
    elseif card == 5 then
        return 39 -- Go to H2
    elseif card == 6 then
        return 5  -- Go to R1
    elseif card == 7 then
        -- Go to next R (railroad)
        if position == 7 then return 15
        elseif position == 22 then return 25
        elseif position == 36 then return 5
        else return position end
    elseif card == 8 then
        -- Go to next U (utility)
        if position == 7 then return 12
        elseif position == 36 then return 28
        else return position end
    else
        return position
    end
end

-- Main simulation
local current_position = 1  -- Start at GO (position 1)
local doubles_count = 0
local jail_count = 0

for i = 1, num_simulations do
    local roll = roll_dice()
    
    -- Check for doubles
    if roll == 8 then  -- Doubles (4+4)
        doubles_count = doubles_count + 1
        if doubles_count == 3 then
            -- Go to jail
            current_position = 11  -- JAIL
            doubles_count = 0
            visit_count[current_position] = visit_count[current_position] + 1
            goto continue
        end
    else
        doubles_count = 0
    end
    
    -- Move to new position
    current_position = ((current_position + roll - 1) % board_size) + 1
    
    -- Handle special squares
    local square = board[current_position]
    if square == "G2J" or square == "JAIL" then
        current_position = 11  -- JAIL
    elseif square == "CC1" or square == "CC2" or square == "CC3" then
        current_position = next_cc_card(current_position)
    elseif square == "CH1" or square == "CH2" or square == "CH3" then
        current_position = next_ch_card(current_position)
    end
    
    -- Increment visit count
    visit_count[current_position] = visit_count[current_position] + 1
    
    ::continue::
end

-- Find the three most visited squares
local sorted_visits = {}
for i = 1, board_size do
    table.insert(sorted_visits, {position = i, count = visit_count[i]})
end

table.sort(sorted_visits, function(a, b) return a.count > b.count end)

-- Format the result
local result = ""
for i = 1, 3 do
    local square = board[sorted_visits[i].position]
    result = result .. string.format("%02d", sorted_visits[i].position - 1)
end

print("Most likely three-square sequence: " .. result)
print("Top 3 squares:")
for i = 1, 3 do
    local pos = sorted_visits[i].position
    local square = board[pos]
    print(string.format("%s (%d visits)", square, sorted_visits[i].count))
end
```

Wait, let me correct this implementation to properly handle the dice and the actual Monopoly rules:

```lua
-- Euler Problem 84 Solution in Lua
-- Simulate Monopoly game to find most visited squares

math.randomseed(os.time())

-- Define the Monopoly board (0-39)
local board = {
    "GO", "A1", "CC1", "A2", "T1", "R1", "B1", "CH1", "B2", "B3", 
    "JAIL", "C1", "U1", "C2", "C3", "R2", "D1", "CC2", "D2", "D3",
    "FP", "E1", "CH2", "E2", "E3", "R3", "F1", "F2", "U2", "F3",
    "G2J", "G1", "G2", "CC3", "G3", "R4", "CH3", "H1", "T2", "H2"
}

local board_size = 40
local num_simulations = 1000000
local visit_count = {}

-- Initialize visit count for all squares
for i = 0, board_size - 1 do
    visit_count[i] = 0
end

-- Community Chest cards (16 cards: 2 GO, 1 JAIL, others 0)
local cc_cards = {1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
-- Chance cards (16 cards: 8 special, others 0)
local ch_cards = {1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0}

-- Function to get a random card from deck
local function get_card(deck)
    local index = math.random(1, #deck)
    return deck[index]
end

-- Function to simulate dice roll (using 4-sided dice)
local function roll_dice()
    local die1 = math.random(1, 4)
    local die2 = math.random(1, 4)
    return die1 + die2
end

-- Function to get next CC card
local function next_cc_card(position)
    local card = get_card(cc_cards)
    if card == 1 then
        return 0  -- Go to GO
    elseif card == 2 then
        return 10 -- Go to JAIL
    else
        return position
    end
end

-- Function to get next CH card
local function next_ch_card(position)
    local card = get_card(ch_cards)
    if card == 1 then
        return 0  -- Go to GO
    elseif card == 2 then
        return 10 -- Go to JAIL
    elseif card == 3 then
        return 11 -- Go to C1
    elseif card == 4 then
        return 24 -- Go to E3
    elseif card == 5 then
        return 39 -- Go to H2
    elseif card == 6 then
        return 5  -- Go to R1
    elseif card == 7 then
        -- Go to next R (railroad)
        if position == 7 then return 15
        elseif position == 22 then return 25
        elseif position == 36 then return 5
        else return position end
    elseif card == 8 then
        -- Go to next U (utility)
        if position == 7 then return 12
        elseif position == 36 then return 28
        else return position end
    else
        return position
    end
end

-- Main simulation
local current_position = 0  -- Start at GO (position 0)
local doubles_count = 0

for i = 1, num_simulations do
    local roll = roll_dice()
    
    -- Check for doubles
    if roll == 8 then  -- Doubles (4+4)
        doubles_count = doubles_count + 1
        if doubles_count == 3 then
            -- Go to jail
            current_position = 10  -- JAIL
            doubles_count = 0
            visit_count[current_position] = visit_count[current_position] + 1
            goto continue
        end
    else
        doubles_count = 0
    end
    
    -- Move to new position
    current_position = ((current_position + roll) % board_size)
    
    -- Handle special squares
    local square = board[current_position + 1]  -- 1-based indexing for board
    if square == "G2J" or square == "JAIL" then
        current_position = 10  -- JAIL
    elseif square == "CC1" or square == "CC2" or square == "CC3" then
        current_position = next_cc_card(current_position)
    elseif square == "CH1" or square == "CH2" or square == "CH3" then
        current_position = next_ch_card(current_position)
    end
    
    -- Increment visit count
    visit_count[current_position] = visit_count[current_position] + 1
    
    ::continue::
end

-- Find the three most visited squares
local sorted_visits = {}
for i = 0, board_size - 1 do
    table.insert(sorted_visits, {position = i, count = visit_count[i]})
end

table.sort(sorted_visits, function(a, b) return a.count > b.count end)

-- Format the result
local result = ""
for i = 1, 3 do
    result = result .. string.format("%02d", sorted_visits[i].position)
end

print("Most likely three-square sequence: " .. result)
print("Top 3 squares:")
for i = 1, 3 do
    local pos = sorted_visits[i].position
    local square = board[pos + 1]
    print(string.format("%s (%d visits)", square, sorted_visits[i].count))
end
```

This solution simulates a Monopoly game with the following key features:

1. **Board Setup**: Creates the standard Monopoly board with 40 squares
2. **Dice Simulation**: Uses 4-sided dice (as specified in the problem)
3. **Special Squares**: Handles Community Chest (CC) and Chance (CH) cards
4. **Jail Mechanics**: Implements the "3 doubles in a row" rule
5. **Large Simulation**: Runs 1,000,000 simulations to get accurate probabilities
6. **Result Analysis**: Identifies the three most visited squares

The result should be the three most likely consecutive squares in the sequence, which represents the answer to Euler Problem 84.

